<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用 Github Pages 展示你的页面]]></title>
      <url>%2F2017%2F08%2F12%2F%E4%BD%BF%E7%94%A8%20Github%20Pages%20%E5%B1%95%E7%A4%BA%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[如何才能将自己本地的静态页面放到网上方便与同学交(xuan)流(yao)，这个问题一直以来都困扰着我。 这里介绍了两种方法展示你的页面，一种是使用 htmlpreview 插件，一种是在仓库创建 gh-pages 分支。 使用 htmlpreviewhtmlpreview 是 github 上的一个插件，可以帮助你生成预览效果，使用地址 使用 htmlpreview 需要已经托管在 github 上的 html 页面代码以及相关的代码，你可以将 html 链接直接复制上去，也可以自己加前缀。现在以这个仓库为例，进入到 html 代码页面： 复制该页面的 url，添加到目标路径 ，记得两个路径之间的？不要忘了。 使用 gh-pages 分支在 github 客户端上创建分支在需要创建分支的仓库路径下，选择 Branch，输入 Name 为 gh-pages，点击 Create branch 创建分支，并同步。 接着通过下面形式的链接就可以访问了：https://用户名.github.io/仓库名/.../目标页面.html 使用 Git 命令创建分支这里我新建了一个仓库用来测试效果，现在 github 上新建一个仓库。 接着在本地创建一个文件，并进入该文件夹。 这里为了测试我放了一个 test.html 的文件，执行如下命令： 初始化版本库，用于生成.git文件： git init 将文件添加到缓存区： git add test.html 提交当前工作空间的修改内容： git commit -m &quot;test&quot; 将仓库连接到远程服务器， 为仓库地址 git remote add origin &lt;server&gt; 将改动推送到所添加的服务器上： git push -u origin master 执行完这些命令就把 test.html 更新到线上了。 接着我们用 git 命令创建一个 gh-pages 分支： 在origin/master的基础上，创建一个新分支： git checkout -b newBrach origin/master 之后的操作和之前一样，只是 push 的时候是 gh-pages。 git add test.html git commit -m &quot;update&quot; git push -u origin gh-pages 更新线上的仓库就发现已经创建了好了 gh-pages 分支。 接着按照格式输入链接就可以看到效果了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 vue-cli 脚手架工具搭建一个 vue2.0 项目]]></title>
      <url>%2F2017%2F08%2F10%2F%E4%BD%BF%E7%94%A8%20vue-cli%20%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%20vue2.0%20%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[开始用 vue 框架的时候，我只会 &lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt; 然而这种方式可能比较适合入门和熟悉 vue，要进行开发的话还是要使用 vue 的官方命令行工具 vue-cli。 检查 node 和 npm 版本第一次安装 vue-cli 要检查 node 和 npm 的版本，node 要 4.0 以上，npm 要 3.0 以上（node 和 npm 的安装就略过了）。 node -v npm -v 如果不是所要求的版本需要升级，可参考：升级 node.js 和 npm 全局安装 v-clinpm install -g vue-cli 初始化vue init &lt;template-name&gt; &lt;project-name&gt; template-name 是 vue 提供的官方模板，这里我们使用的是 webpack 打包工具。可以使用 vue list 命令查看所有可用的官方模板。 vue init webpack vue-demo 然后会有一些选项： 选项 描述 Project name 项目名称 Project description 项目描述 Author github 用户名 Vue build 构建方式（独立构建、运行时构建，默认为独立构建） Vue-router vue 路由，其实并不建议第一次用 vue-cli 的时候使用 vue-router，因为自动生成的项目会变得有些复杂，不好分析，后面用到的时候可以再安装 ESlint js 的代码检查工具，默认为 standard 标准安装 unit tests（Karma+Mocha） 单元测试，暂时忽略 e2e tests（Nightwatch） 端到端测试，暂时忽略 然后进入文件夹，安装依赖，运行项目 cd vue-demo npm install 安装所有依赖 npm run dev 运行 然后浏览器会自动打开 http://localhost:8080/ 就可以看到如下图所示的页面了。 到此为止，一个 vue 项目就基本搭建好了。 分析项目目录结构接着我们来分析一下项目的目录结构： 文件 描述 build 和 config webpack 配置相关文件 node_modules 通过 npm install 安装的依赖代码库 src 存放项目源码（开发的所有代码） static 存放第三方静态资源 .babelrc babel 的一些配置，babel 的作用是将 ES6 转换成 ES5 .editorconfig 编辑器的配置（编码方式，缩进风格等等） .eslintignore 不对这些文件做语法检查 .eslintrc eslint 的配置，在这里你可以改变默认的一些代码风格，比如句末分号等等 .gitignore 上传到 git 仓库时，忽略这些文件 .postcssrc.js 加载配置文件 index.html 项目的入口 html 文件 package.json 包管理 README.md 项目说明文件 接着我们可以分析一下与界面直接相关的文件与代码。 先看主目录下的入口 html 文件：index.html 发现只有一个 id 为 app 的 div，接着看 src 文件夹中的项目代码： assets 文件夹中存放的是一些静态资源文件，这里只放了一张 logo的图片。 components 文件夹存放的是组件，在 vue 中一个组件对应就是一个 .vue 文件，可以看做是 html 标签的拓展与复用，这里只有一个 hello.vue。 App.vue 这是整个页面的 vue 实例。 main.js 是项目的入口 js 文件。 先看 main.js 入口文件： // 使用 import from 的方式加载模块或组件 import Vue from &apos;vue&apos; import App from &apos;./App&apos; // 关闭生产模式下给出的提示 Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ el: &apos;#app&apos;, // 挂载到一个 id 为 app 的元素上（见index.html） template: &apos;&lt;App/&gt;&apos;, // 渲染组件 // components 用来注册组件 components: { App } // 引入的组件 }) 可以发现，main.js 引入了主实例 App.vue，并渲染到 index.html 上。 然后再看 App.vue： &lt;template&gt; &lt;div id=&quot;app&quot;&gt; ![](./assets/logo.png) &lt;hello&gt;&lt;/hello&gt;&lt;!-- 使用 hello 组件 --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 引入了 hello 组件 import Hello from &apos;./components/Hello&apos; export default { name: &apos;app&apos;, components: { Hello } } &lt;/script&gt; &lt;style&gt; ... &lt;/style&gt; 我们发现在 App.vue 中引入并使用了 hello 组件，至此还没发现任何与看到的页面相关的内容，怀着终于走到终点的心情打开了最后一个文件，惊觉原来如此，所有的东西都在这啊。 总而言之，我们在页面上看到的内容（除图片外）都是在 Hello.vue 这个文件定义的，作为一个可以重复使用的组件，被引入了 App.vue 这个实例中，App.vue 这个组件可以看做整个项目的主实例，而 App 这个组件又是通过 main.js 初始化并挂载到 index.html 中渲染的，至于说为什么没有 script 这样显式关联的语句，就是 webpack 的功劳了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生 js 计算 html 中出现次数最多的标签]]></title>
      <url>%2F2017%2F08%2F08%2F%E5%8E%9F%E7%94%9F%20js%20%E8%AE%A1%E7%AE%97%20html%20%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[前几天学姐跟我讨论了一道题，觉得还挺有意思的。 题目描述：请使用原生 JavaScript 实现一个方法，判断 html 中出现次数最多的标签，并统计这个次数。 解题思路： 取到页面中所有标签，这里是会有重复的； 遍历所有标签，统计每个标签出现的次数。 其实统计标签出现的次数很容易想到 key-value 的形式，key 存储标签名，value 存储出现的次数，遍历时发现一个就对 value+1。因此就涉及到了 ES6 一个新的特性 Map 数据结构：阮一峰 ES6教程 Map 数据结构。代码如下：12345678910111213141516171819var bodyNodes = document.body.getElementsByTagName('*'); // 获得所有标签，类型为 objectvar map = new Map();var key; // 所求标签var max = 0; // 所求最大值for (let i = 0, len = bodyNodes.length; i &lt; len; i++) &#123; var ele = bodyNodes[i]; var item = ele.localName; // 标签名 if (map.has(item)) &#123; // map 中已存在该标签 if (max &lt; map.get(item) + 1) &#123; // 加入后次数最大 max = map.get(item) + 1; key = item; // 保存该标签名 &#125; map.set(item, map.get(item) + 1); // 替换旧值 &#125; else &#123; // map 中不存在该标签 map.set(item, 1); &#125;&#125; 解题过程中想当然的把 bodyNodes 当成了标签名，实际 bodyNodes 是包含了整个标签的所有属性的一个对象（随意打开的一个网站，东西有点乱，见谅啊）。 然后任意点开一个标签对象，可以找到一个 localName 属性： 整个 map 结构就像这样： 整个解题过程就是这样，其实并不复杂，只是觉得挺有意思的，然后了解了一下 ES6 的 Map 数据结构，所以记录一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 数据类型小结]]></title>
      <url>%2F2017%2F06%2F06%2FJavaScript%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[我们可以将 JavaScript 中所有数据分为基本数据类型和引用类型，基本数据类型存在在栈中，引用类型存在堆中，变量名存储的是一个指向堆中的地址。 基本数据类型一共有五种基本数据类型：数值型 Number、字符串 String、布尔型 Boolean、Undefined 型、Null 型。 数值型数值型有整数型和浮点型，整数有十进制、八进制（严格模式下无效）、十六进制，其他进制在计算时都会转换为十进制。 浮点型保留小数点后十七位，有 e 指数表示形式。 数值型有一个特别的值：NaN（Not a Number），NaN 表示一个本来要返回数值的操作数未返回数值的情况，比如除数为 0 的情况，这样可以避免抛出错误，不影响其他代码的执行。 涉及任何 NaN 的操作都会返回 NaN；NaN 与任何值都不相等，包括它自己。可以用 isNaN() 方法判断，其他数据类型自动转换为数值类型。 12345isNaN(NaN); // falseisNaN(7); // falseisNaN("7"); // falseisNaN("echo"); // trueisNaN(false); // false 字符串用单引号或者双引号括起来的就叫字符串，引号嵌套可以用转义字符。 布尔型布尔型有两个值：true 和 false。 UndefinedUndefined 型只有一个值：undefined，表示变量声明了但未初始化。 12var msg;console.log(msg); // undefined NullNull 型也只有一个值：null，表示空对象指针，若定义的变量想用来保存对象，最好将其初始化为 null。 关于 null 和 undefinedundefined 是 null 派生而来。 12undefined == null; // trueundefined === null; //false 相互转换其他 – &gt; 数值转换情况： Number()、parseInt()、parseFloat()、一元加运算符。 Number()Number() 的效果与一元加运算符等效（+ 一边是字符串时，+ 为连接符）。 true –&gt; 1；false –&gt; 0；null – &gt;0；undefined –&gt; NaN。 空字符串 –&gt; 0；非空字符串全为数值时，直接转换为数值型，忽略八进制前缀 0（即不转换为八进制），不忽略十六进制前缀 0x，其他字符串为 NaN。 12345678910Number(true); // 1Number(false); // 0Number(null); // 0Number(undefined); // NaNNumber(""); // 0Number("123"); // 123Number("0123"); // 123Number("0x123"); // 291Number("123echo"); // NaNNumber("echo"); // NaN parseInt()由于 Number() 函数转换字符串时复杂且不太合理，所以我们一般使用 parseInt() 将字符串转换成整数，使用 parseFloat() 转换成浮点数。parseInt() 会忽略字符串前面的空格，如果第一个非空字符是数字，函数会一直解析到第一个非数字字符。 123456789101112parseInt(true); // NaNparseInt(false); // NaNparseInt(null); // NaNparseInt(undefined); // NaNparseInt(""); // NaNparseInt("123"); // 123parseInt("123.4"); // 123parseInt("0123"); // 123parseInt("0x123"); // 291parseInt("123echo"); // 123parseInt("echo"); // NaNparseInt("echo123"); // NaN 我们可以看到除了非空字符串，parseInt() 均返回 NaN，因此 parseInt() 通常只用于字符串转数值的情况。 parseFloat()类似 parseInt()，parseFloat() 不同的只是不会忽略字符串中的小数点。 其他 – &gt; 布尔在使用 Boolean(xxx) 方法，或条件和循环中的判断语句中其他数据类型会转换成布尔型。 对于基本数据格式：数值（0/NaN）、空字符串、null、undefined 转为 false。其余转换为 true。 其他 – &gt; 字符串加号操作符（连接符）一元加号运算符除了计算之外，还有一个用途就是连接字符串与其他数据类型。 123456"echo" + 123; // "echo123""echo" + true; // "echotrue"var age = 18;"echo" + age; // echo18"echo" + null; // "echomull""echo" + undefined; // "echoundefined" toString()1xxx.toString(2/8/10/16) String()1String(xxx) toString() 与 String() 的区别在于：null 和 undefined 没有 toString() 这个方法。所有基本数据类型都有 String() 方法。 引用类型引用类型是一种数据类型，引用类型的值也叫对象，常见的引用类型有 Object、数组 Array、正则表达式 Rep、日期 Date、函数 Function 等。由于数组的方法较多容易混淆，所以只归纳了数据的一些常用方法。 数组常用方法push(elements)： 添加到数组尾部，返回新数组长度。 pop()： 移除数组最后一项，返回移除元素。 shift()： 移除数组第一项，返回移除元素。 unshfit(elements)： 添加到数组头部，返回新数组长度。 reverse()： 反转数组。 sort()： 排序方法，直接使用 sort 方法会默认调用 toString()，因此通常使用比较函数。 123arr.sort(function(a,b) &#123; // 从小到大 return a - b;&#125;); arr.concat(arrs)： 连接多个数组，返回新数组 splice()： 删除/插入数组，不影响原数组。 123arr.splice(start)arr.splice(start, deleteCount) arr.splice(start, deleteCount, item1, item2, ...) indexOf()/lastIndexOf()： 查找某一项所在位置，返回索引，默认使用全等符号。 every()： 对数组中每一项执行给定函数，若每一项返回 true 则返回 true。 filter()： 对数组中每一项执行给定函数，返回所有返回 true 的项组成的数组。 forEach()： 对数组中每一项执行给定函数，无返回。 map()： 对数组中每一项执行给定函数，返回所有结果。 some()： 对数组中每一项执行给定函数，若任一项返回 true，则返回 true。 redeuce()/reduceRight()： 函数返回值会左右第一个参数自动传给下一项，类似迭代。 join(“连接符”)： 通过连接符将数组转换成字符串。同样可以通过 split(“连接符”) 方法将字符串转换成数组。 1234var arr = [1,2,3,4,5];var sum = arr.reduce(function(prev,cur,index,array) &#123; return prev + cur;&#125;); // 15 类型检测typeoftypeof 不能检测出具体引用数据类型，特别地 null 返回 object。 typeof 返回值：object、number、string、boolean、undefined（变量未声明或者声明了未初始化）、function 1234567891011121314151617var arr = [];var oNum = 123;var oStr = "Echo";var oBoolean = false;var oo;var fun = funtion() &#123; console.log("I am a function");&#125;typeof arr; // objecttypeof null; // objecttypeof oNum; // numbertypeof oStr; // stringtypeof oBoolean; // booleantypeof oo; // undefinedtypeof yy; // undefinedtypeof fun; // function typeof 经常用来判断一个变量是否存在。 1if (typeof xx != "undefined") &#123;&#125; instanceofinstanceof 一般用来判断对象的具体类型，或者判断某个变量是否是某个对象的实例。 1234var arr = [];arr instanceof Array; // truearr instanceof Object; // trueArray instanceof Object; // true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 面向对象编程系列（二）继承]]></title>
      <url>%2F2017%2F05%2F26%2FJavaScript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[不像 Java，JavaScript 中并没有类的概念，因此要想实现继承，必须依靠 JavaScript 中的原型（prototype）机制。 继承的目的是使子类别具有父类别的属性和方法，子类别可以重新定义某些属性，也可以重写某些方法，子类别也可以添加新的属性和方法。 子类别可以继承父类别的属性和方法，但不是所有的属性和方法，因此我们做以下约定： 12345678910111213141516function Fun()&#123; // 私有成员 var val = ...; // 私有基本属性 var arr = ...; // 私有引用属性 function fun()&#123;...&#125; // 私有函数（方法） // 实例成员 this.val = ...; // 实例基本属性 this.arr = ...; // 实例引用属性 this.fun = function()&#123;...&#125;; // 实例函数（方法）&#125;// 原型成员Fun.prototype.val = ...; // 原型基本属性Fun.prototype.arr = ...; // 原型引用属性Fun.prototype.fun = function()&#123;...&#125;; // 原型函数（方法） 只有父类别的实例成员才可以被继承，私有成员是不能被继承的。 接下来介绍实现继承的六种方法：构造函数继承、原型链继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。 构造函数继承实现原理： 将父对象的构造函数绑定在子对象上，父对象中的所有实例属性和方法复制到子对象，没有用到原型链。 123456789101112131415161718192021222324function Animal(age) &#123; this.species = "动物"; this.age = age; this.sayAge = function() &#123; console.log(this.age); &#125;&#125;function Dog(name,age) &#123; //Animal.call(this,age); Animal.apply(this,[age]); this.name = name; this.sayName = function() &#123; console.log(this.name); &#125;&#125;var teddy = new Dog("Teddy",7);teddy.name; // "Teddy"teddy.age; // 7teddy.species; // "动物"teddy.sayName(); // "Teddy"teddy.sayAge(); // 7 在父对象 Animal 的构造函数中定义了 species 和 age 两个属性，和 sayAge 方法，在子对象 Dog 中调用 call() 或 apply() 方法使父对象的构造函数绑定到子对象上，子对象拥有父对象的所有实例属性和方法，Dog 对象的一个实例 teddy 也拥有其构造函数 Dog 上的所有属性和方法（包括 Dog 从 Animal 中继承过来的）。 优点： 子对象可以向父对象传递参数，如上述代码中的 age 可以实现多继承，即多次调用 call()/apply() 方法 父对象的属性和方法只是被复制，不被共享，避免了污染 缺点： 方法都是定义在构造函数中，无法被复用，继承时，每个子对象都有父对象方法的副本，造成内存的浪费 子对象只能继承父对象构造函数中的属性和方法，无法继承其原型对象中的属性和方法 12345Animal.prototype.sleep = function()&#123; console.log("sleep");&#125;;Animal.prototype.head = 1; 比如在父对象 Animal 的原型对象中添加一个 sleep 方法和 head 属性，子对象 Dog 的实例 teddy 是无法继承这些属性和方法的。 12teddy.sleep(); // errorteddy.head; // undefined 但是在 Dog 的原型对象上定义的属性和方法，teddy 还是可以使用的，这主要还是因为 teddy 是 Dog 直接 new 出来的实例。 注意：借用构造函数实现的继承与原型链并没有关系。 1234567Animal.prototype.__proto__; // Object.prototypeDog.prototype.__proto__; // Object.prototypeteddy.__proto__; // Dog.prototype// Animal.prototype --&gt; Object.prototype// Dog.prototype --&gt; Object.prototype// teddy --&gt; Dog.prototype 可以看到父对象 Animal 和子对象 Dog 两者的原型对象之间并没有关联。 原型链继承实现原理： 子类的原型对象指向父类的一个实例，实现原型链的连接。 12345678910111213141516171819202122232425262728293031323334// 父构造函数function Animal() &#123;&#125;// 父原型对象Animal.prototype.sleep = function()&#123; console.log("sleep");&#125;;Animal.prototype.head = 1;// 子构造函数function Dog() &#123;&#125;// 实现原型链继承Dog.prototype = new Animal();// 子原型对象Dog.prototype.sound = function()&#123; console.log("汪汪");&#125;;Dog.prototype.feet = 4;// 实例var teddy = new Dog();teddy.sleep(); // sleepteddy.head; // 1teddy.sound(); // "汪汪"teddy.feet; // 4Animal.prototype.__proto__; // Object.prototypeDog.prototype.__proto__; // Animal.prototypeteddy.__proto__; // Dog.prototype// teddy --&gt; Dog.prototype --&gt; Animal.prototype --&gt; Object.prototype 只是单纯的使用 new 操作符创建一个父类实例：1Dog.prototype = new Animal(); 会有一个问题： 1Dog.prototype.constructor; // Animal 我们发现子类原型对象的 constructor 属性指向了父类构造函数。更重要的是，每一个实例也有一个 constructor属性，默认调用 prototype 对象的 constructor 属性。 12teddy.constructor == Dog.prototype.constructor // trueteddy.constructor; // Animal 解决办法： 手动纠正，为 prototype 属性重新赋值。 123// 实现原型链继承Dog.prototype = new Animal();Dog.prototype.constructor = Dog; 优点： 实例可以继承子类和父类原型对象中的属性和方法 父类原型对象新增属性和方法，子类实例仍可以访问 缺点： 无法实现多继承 无法向父类构造函数传参 对子类原型的修改会反映到父类原型对象 组合继承组合继承融合了原型链和构造函数的优点，是常用的继承模式。 实现原理： 使用原型链实现原型属性和方法（共享）的继承，使用构造函数实现对实例属性的继承。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 父构造函数function Animal(name) &#123; this.name = name; this.friends = ["Echo","Mike"];&#125;// 父原型对象Animal.prototype.color = ["black","white"]Animal.prototype.sayName = function(name) &#123; console.log(this.name);&#125;;// 子构造函数function Dog(name,age) &#123; // 借用构造函数继承 Animal.call(this,name); // 第二次调用 this.age = age;&#125;// 实现原型链继承Dog.prototype = new Animal(); // 第一次调用Dog.prototype.constructor = Dog; // 子原型对象Dog.prototype.sayAge = function()&#123; console.log(this.age);&#125;;Dog.prototype.feet = 4;// 实例var teddy = new Dog("Teddy",3);var samoyed = new Dog("Samoyed",7);teddy.name; // "Teddy"teddy.friends.push("Lily"); teddy.friends; // ["Echo","Mike","Lily"]teddy.color.push("brown");teddy.color; // ["black","white","brown"]teddy.sayName(); // Teddyteddy.age; // 3teddy.sayAge(); // 3teddy.feet; // 4samoyed.name; // "Samoyed"samoyed.friends; // ["Echo","Mike"]samoyed.color; // ["black","white","brown"]samoyed.sayName(); // Samoyedsamoyed.age; // 7samoyed.sayAge(); // 7samoyed.feet; // 4 优点： 子对象可以向父对象传递参数，可以实现多继承，继承自构造函数中的实例属性不会被污染 子对象共享继承自原型链中的属性和方法 缺点： 无论什么时候都会调用两次构造函数。 原型式继承很多时候我们不一定会有或者说通过构造函数实现继承，可能我们只有两个对象，我们想实现这两个对象的继承。本例参考阮一峰老师的博客 123456var Chinese = &#123; nation: "中国"&#125;var Doctor = &#123; career: "医生"&#125; json 的发明人提出一个 object() 函数： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 在 object() 函数内部，先创建了一个临时的构造函数，将传入对象作为该构造函数的原型对象，最后返回该构造函数的一个实例。实际上就是父对象传入 object() 函数，返回子对象，继承关系还是通过原型链实现的。 12var Doctor = object(Chinese);Doctor.nation; // "中国" 同样的，在父对象的属性和方法的任何修改会反映到子对象上。 12Chinese.age = 18;Doctor.age; // 18 寄生式继承寄生式继承创建个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。 12345678910111213141516171819function createAnother(original)&#123; var clone = Object.create(original); // 通过调用函数创建一个新对象 clone.sayHi = function() &#123; // 以某种方式来增强这个对象 console.log("Hi"); &#125;; return clone; // 返回这个对象&#125;var person = &#123; name: "Bob", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // "Hi"person.sayHi(); // 报错anotherPerson.friends.push("Echo");anotherPerson.friends; // ["Shelby", "Court", "Van", "Echo"]person.friends; // ["Shelby", "Court", "Van", "Echo"] createAnother() 函数接收了一个参数，即被继承对象。 anotherPerson 是基于 person 创建的一个新对象，新对象不仅具有person的所有属性和方法，还有自己的 sayHi() 方法。但是父对象的引用属性是共享的。 寄生组合式继承寄生组合式继承主要是对组合继承的改进，在组合继承中，最大的问题就是无论什么时候都会调用两次构造函数。 12345678910// 子构造函数function Dog(name,age) &#123; // 借用构造函数继承 Animal.call(this,name); // 第二次调用Animal() this.age = age;&#125;// 实现原型链继承Dog.prototype = new Animal(); // 第一次调用Animal()Dog.prototype.constructor = Dog; 为了解决这一问题，寄生组合式继承 通过借用构造函数来继承属性，通过原型链来继承方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 面向对象编程系列（一）创建对象]]></title>
      <url>%2F2017%2F05%2F06%2FJavaScript%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[要说 JavaScript 什么最难，对象首当其冲。 对象的含义ECMA-262 对于对象的官方定义是： 无序属性的集合，其属性可以包括基本值、对象或者函数。 对象的属性是由键对值（key: value）形式定义的，当 value 值为函数时，则称为方法。通常我们将对象的特征称之为属性，对象的行为称之为方法。 比如将我这个人作为一个对象，我拥有很多属性，姓名、性别、年龄，还有很多方法，比如能吃能睡能打麻将。 我在刚开始学 JavaScript 的时候，一直弄不清什么是构造函数、原型对象和实例，还有他们之间的关系，在总结创建对象的几种方法之前，先聊一聊这三个东西。 构造函数、原型对象、实例定义构造函数构造函数就是用 new 操作符调用的普通函数，构造函数与普通函数的 唯一区别 在于：构造函数用 new 调用来创建对象，例如 Object、Array、Function等，都是构造函数。 使用构造函数的 目的 就是：所有用同一个构造函数创建的实例对象都具有同样的属性和方法。 一般构造函数名的 首字母大写 用以区别，比如下面代码中的 Person。 123456789function Person(name,age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(this.name + "爱吃排骨"); &#125;&#125;var Echo = new Person("Echo",18); 实例对象实例对象，通常简称为 实例，是通过 new 调用构造函数创建出的对象，例如上述代码中的 Echo 就是实例化出来的一个对象，实例拥有构造函数中的所有属性与方法。 原型对象所有函数都有一个 prototype 属性，指向这个构造函数的原型对象，这个原型对象里的属性和方法是所有实例共享的。 三者的关系函数的 prototype 属性，指向这个构造函数的原型对象。 原型对象的 constructor 属性，指向它的构造函数。 实例中的 [[prototype]] （除 IE 外的浏览器也支持 __proto__ 属性）指向原型对象。 12345678910111213141516171819202122232425262728function Person(name,age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(this.name + "爱吃排骨"); &#125;&#125;var Echo = new Person("Echo",18);var Mike = new Person("Mike",20);Echo.sex = "女";Mike.job = "学生";Person.prototype.sayHi = function(argument) &#123; console.log("Hi " + this.name);&#125;;Person.prototype.score = 100;Echo.sayHi(); // Hi EchoEcho.score = 80;console.log(Echo.score); // 80console.log(Mike.score); // 100Echo.__proto__.score = 60;console.log(Echo.score); // 80console.log(Mike.score); // 60 在上述代码中，属性 name 和 age，方法 eat 是构造函数中定义的，实例 Echo 自有属性 sex，实例 Mike 自有属性 job，原型对象中共享属性 score 和方法 sayHi。后在实例 Echo 中添加同名自有属性 score，在调用属性时，先自有属性后共享属性。改变原型对象中的属性，所有实例的该属性同时改变。 检测属性要判断对象是否具有某个属性，通常有两种方法。 in 操作符in 操作符会检查对象自有属性和原型属性。 12console.log("score" in Mike); // trueconsole.log("age" in Mike); // true hasOwnProperty 方法hasOwnProperty 方法只检查对象的自有属性。 12console.log(Mike.hasOwnProperty("name")); // trueconsole.log(Mike.hasOwnProperty("score")); // false 创建对象的方法字面量创建对象最简单的方式就是字面量。 123456789var Echo = &#123; name: "Echo", age: 18, eat: function() &#123; console.log("Echo 爱吃排骨"); &#125;&#125;;console.log(Echo.__proto__); // Object 在使用字面量方式创建对象时，可以在定义对象时添加属性，也可以先创建一个空对象，后续再添加属性，属性名 可以是 变量 的形式，也可以是 字符串 形式。 123456var Echo = &#123;&#125;;Echo.name = "Echo";Echo.age = 18;Echo.eat = function() &#123; console.log("Echo 爱吃排骨");&#125; 优点： 创建方式简单，代码量少，可读性好。 缺点： 代码不具有复用性，比如说还有个人跟我一样的年纪跟我一样爱吃排骨，那我们又要创建一个新的对象，定义一样的属性，这样会造成代码的冗余。 通过字面量方式直接创建的实例对象，该实例的 __proto__ 属性指向 Object，即实例的原型对象为 Object 对象。 内置构造函数 Object12345678var Echo = new Object();Echo.name = "Echo";Echo.age = 18;Echo.eat = function() &#123; console.log("Echo 爱吃排骨");&#125;console.log(Echo.__proto__); // Object 实际上，字面量方式创建对象也是通过 Object 类型创建的，只是表示方式不一样而已。 工厂模式工厂模式通过创建一个函数定义属性和方法，所有通过这个函数创建的实例对象，自动拥有函数中所有的属性和方法。 123456789101112131415161718function person(name,age) &#123; var o = new Object(); o.name = name; o.age = age; o.eat = function() &#123; console.log(o.name + "爱吃排骨"); &#125; return o;&#125;var Echo = person("Echo",18);console.log(Echo.age); // 18Echo.eat(); // Echo爱吃排骨var Mike = person("Mike",20);console.log(Echo.__proto__); // Objectconsole.log(person.prototype); // Objectconsole.log(person.constructor); // Function 优点： 可以方便地创建多个具有相同属性和方法的对象。 缺点： 通过工厂模式创建的函数与实例，原型对象均为 Object，这样我们就无法判断实例的实际类型。 自定义构造函数1234567891011121314151617function Person(name,age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(this.name + "爱吃排骨"); &#125;&#125;var Echo = new Person("Echo",18);Echo.eat(); // Echo爱吃排骨var Mike = new Person("Mike",20);Mike.eat(); // Mike爱吃排骨Mike.name = "Hello Mike";console.log(Echo.name); // Echoconsole.log(Mike.name); // Hello Mike 与工厂模式的区别： 没有在函数内显性创建对象 通过 this 对属性和方法赋值 没有 return 语句 之所以构造函数方法会与工厂模式有这些区别，关键还在于 new 操作符。 new 操作符的作用： 创建一个新的对象 this 指向这个对象 往对象添加属性和方法（执行代码） 返回对象 优点： 所有用同一个构造函数创建的实例对象都具有同样的属性和方法，解决了对象识别问题。 缺点： 实际上并没有消除代码冗余，构造函数中的属性和方法会在每个实例中重新创建一遍，不同实例之间的属性和方法相互独立，这样就存在内存浪费问题，而事实上没有必要创建多个完成同一任务的方法。 原型模式单纯使用原型对象来创建实例对象也需要创建一个构造函数，当然这个构造函数可以是空的。通过原型对象添加属性和方法： 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = "Echo";Person.prototype.eat= function()&#123; console.log(this.name + "爱吃排骨");&#125;;var Echo = new Person();console.log(Echo.name); // EchoEcho.eat(); // Echo爱吃排骨var Mike = new Person();console.log(Mike.name); // EchoMike.eat(); // Echo爱吃排骨 可以看到通过原型对象定义的方法和属性是共享的。除此之外，还有一种更简洁的字面量形式定义原型对象的属性和方法。 123456789101112function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: "Echo", eat: function() &#123; console.log(this.name + "爱吃排骨"); &#125;&#125; 使用字面量形式必须注意： 指明该原型对象的构造函数，否则实例的 __proto__ 属性指向 Object。 优点： 对于不同实例的同一个属性和方法其实都是同一个内存地址，避免了内存浪费，提高运行效率。 缺点： 共享引用类型（对象）时，一个实例的改变会影响另一个实例，我们有的时候需要这种共享性，有的时候会恼怒这种共享性。 12345678910111213141516function Person(name,age) &#123;&#125;Person.prototype = &#123; constructor: Person, friends: ["Lily","Jack"]&#125;var Echo = new Person();var Mike = new Person();console.log(Echo.friends); // ["Lily","Jack"]console.log(Mike.friends); // ["Lily","Jack"]Echo.friends.push("Lucy");console.log(Echo.friends); // ["Lily","Jack","Lucy"]console.log(Mike.friends); // ["Lily","Jack","Lucy"] 组合使用构造函数模式和原型模式这种创建对象的方式是目前使用最广泛的，它结合了构造函数模式与原型模式的优点，利用构造函数定义实例属性，利用原型对象定义方法和共享属性。 123456789101112131415161718192021function Person(name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; constructor: Person, sayHi: function() &#123; console.log("Hi " + this.name); &#125;, friends: ["Lily","Jack"]&#125;var Echo = new Person("Echo",18);var Mike = new Person("Mike",20);Echo.sayHi(); // Hi EchoMike.sayHi(); // Hi Mikeconsole.log(Echo.friends); // ["Lily","Jack"]console.log(Mike.friends); // ["Lily","Jack"]Echo.friends.push("Lucy");console.log(Echo.friends); // ["Lily","Jack","Lucy"]console.log(Mike.friends); // ["Lily","Jack","Lucy"] 其他方法在《JavaScript 高级程序设计》中还提到了三种其他创建对象的方法：动态原型模式、寄生构造函数模式、稳妥构造函数模式。由于这三种方式并不常用，因此简单了解一下即可。 动态原型模式通过检查检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 寄生构造函数模式构造函数的内部与工厂模式相同，使用 new 调用构造函数。 稳妥构造函数模式形式上与工厂模式相同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器常见的兼容问题]]></title>
      <url>%2F2017%2F04%2F20%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[浏览器常见的兼容问题、原因、解决方法不同浏览器的标签默认的 margin 和 padding 不同描述同一标签在不加样式的情况下，在不同浏览器下的 margin 和 padding 值相差较大。例如列表、图片等。 解决1234* &#123; margin: 0; padding: 0;&#125; 块级元素浮动 + 横向margin描述块级元素浮动 + 横向 margin，在 IE6 上 margin 值比设置值大，可能会导致 IE6 后面的一块被挤到下一行。 解决将浮动的块级元素设置为行内元素（display: inline;） 字体大小定义不同描述对 small 属性定义不同，Firefox 为 13px，IE 为 16px。 解决采用固定像素值或相对单位设置字体大小。 图片有默认间距描述图片一行排列时会有默认间距，Firefox：5px，IE 和 Chrome：4px。 解决设置图片浮动。 盒子模型描述盒子模型有两种，一种为 W3C 模式：为元素设置宽（width）和高（height）就是为内容（content）设置；一种为 IE 模式：内容（content）+ 填充（padding）+ 边框（border）才等于元素的宽高。IE8 及以下版本在混杂模式下为 IE 模式，其他情况均为 W3C 模式。 解决保证 DOCTYPE 声明正确，确保布局均为 W3C 盒子模型。 透明度描述IE8 及以下版本不支持 opacity 属性。 解决12opacity: 0.6 /* 0-1 */filter:Alpha(opacity=50); /* IE8 及以下版本，范围为 0-100 */ innerText描述获取标签内文本时，Firefox 不支持 innerText，但支持 textContent；IE8 及以下不支持 textContent。 解决123456if (navigator.appName.indexOf("Explorer") &gt; -1) &#123; document.getElementById('element').innerText = "my text";&#125;else &#123; document.getElementById('element').textContent = "my text";&#125; 不能识别 min-/max- 前缀描述IE6 及以下版本并不能识别 min-/max- 前缀。 解决12345min-width: 600px;width:expression(document.body.clientWidth &lt; 600 ? "600px" : "auto" );max-width: 600px;width:expression(document.body.clientWidth &gt; 600 ? "600px" : "auto" ); ul 和 ol 列表缩进问题描述对于非 IE 浏览器和 IE8 及以上版本而言，设置 margin: 0; 可以去除上下空白；设置 padding: 0; 可以去除列表编号或原点、左右空白。 对于 IE7 及以下版本浏览器而言，设置 margin: 0; 可以去除列表编号或原点、左右空白；设置 padding: 0; 无任何变化。 解决同时设置 margin 和 padding 均为 0。 常见 hack 技术概念由于不同厂商的浏览器，比如 IE、Safari、Firefox、Chrome 等，或者是同一厂商的浏览器的不同版本，如 IE6 和 IE7，对 CSS 的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的 CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack为不同版本的浏览器定制编写不同的 CSS 效果。 分类选择器前缀法12*html selector&#123;color:blue;&#125; /* *html前缀只支持IE6 */*+html selector&#123;color:blue;&#125; /* *+html前缀只支持IE7 */ 属性前缀法1234567.header &#123;_width:100px;&#125; /* 下划线"*"——IE6专用 */.header &#123;*+width:100px;&#125; /* 星号加号"*+"——IE7专用 */.header &#123;*width:100px;&#125; /* 星号"*"——IE6、IE7共用 */ .header &#123;width:100px\0;&#125; /* "\0"——IE8、IE9共用 */.header &#123;width:100px\9;&#125; /* "\9"——IE6、IE7、IE8、IE9共用 */.header &#123;width:330px\9\0;&#125; /* "\9\0"——IE9专用 */ IE6 能识别下划线和星号，IE7 只能识别星号，但不能识别下划线，IE6-IE10 都能识别 “\9”。 条件注释法（一般用于 IE6-IE9）1234567891011121314151617181920212223&lt;!--[if IE 6]&gt; 只在 IE6 下显示&lt;![endif]--&gt;&lt;!--[if !IE]&gt; 在非 IE 显示&lt;!--&lt;![endif]--&gt;&lt;!--[if lt IE 8]只在 IE8 以下（不含IE8）版本显示&lt;![endif]--&gt;&lt;!--[if lte IE 8] 只在 IE8 以下（含IE8）版本显示&lt;![endif]--&gt;&lt;!--[if gt IE 8] 只在 IE8 以上（不含IE8）版本显示&lt;![endif]--&gt;&lt;!--[if gte IE 8] 只在 IE8 以上（含IE8）版本显示&lt;![endif]--&gt; 条件注释法中还可以用与（&amp;）、或（|）运算符。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件模型系列（四）jQuery 中的事件模型]]></title>
      <url>%2F2017%2F04%2F06%2FJavaScript%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89jQuery%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[前言jQuery中提供了四种事件绑定方式，分别是bind、live、delegate、on，对应的解除监听的函数分别是unbind、die、undelegate、off。 先声明一个例子，各函数的用法将围绕这个例子。 12345678910111213&lt;ul id="uList"&gt; &lt;li id="list1" class="item"&gt;列表元素1&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素2&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素3&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素4&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素5&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; function getText() &#123; console.log(this.innerHTML); &#125;&lt;/script&gt; 原理on1$(element).on(type,[selector],[data],fn); type：事件类型（不带 on，打引号） selector：可选，触发事件的元素，若没有设置则默认为 element data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 data 参数的使用：1234567// 附加数据可以为任意类型var userObj = &#123; name: "Echo", age: 18 &#125;;// 为所有p元素绑定click事件，并传入附加数据(user)$("p").on( "click", userObj, function(event)&#123; console.log(event.data.name); // Echo&#125; ); 我们看到前有调用 on 的元素 element，后有函数参数 selector，那么二者之间的关系是什么呢，我们先不设置 selector，那么事件处理程序和事件都会默认绑定在 element 上。 1$("#uList").on("click",getText); 再将 selector 设置为 li 时， 123$("#uList").on("click","li",getText);// 点击列表元素 1// 列表元素1 这样看，还有点事件委托的意味，调用该方法的元素 element 绑定了事件处理程序，而参数中的 selector 才是触发事件的元素。 bind1$(element).bind(type,[data],fn); type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 在最开始学 jQuery 的时候，用的最多的就是 bind 方法。来看 bind 的源码： 123function (types, data, fn) &#123; return this.on (types, null, data, fn);&#125; 可以看到 bind 是调用了 on 方法，并设置 selector 属性为 null。1$("#uList").bind("click",getText); 123$("#list1").bind("click",getText);// 点击列表元素 1// 列表元素1 live1$(element).live(type,[data],fn); type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 live 源码： 1234function (types, data, fn) &#123; jQuery (this.context).on(types, this.selector, data, fn); return this;&#125; live 方法其实也是调用了 on 方法，但不是绑定到调用的元素上，而是绑定到 this.context，那 context 又是什么呢，我个人认为就是该元素的上下文，在可以使用 live 方法的 jQuery 版本下： 12$("#uList").context; // #document"#list1").context; // #document 而在 jQuery1.7 以上版本： 12$("#uList").context; // undefined$("#list1").context; // undefined 因此这就导致了一个弊端，将所有事件都委托到根节点上，根节点负担太大，并且在 DOM 节点较为复杂时会有意料之外的结果，所以 jQuery1.7 之后就废弃了 live 方法。 1$("#uList").live("click",getText); 123$("#list1").on("click",getText);// 点击列表元素 1// 列表元素1 delegate1$(element).delegate(selector,type,[data],fn); selector：触发事件的元素 type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 对于一下 on 方法： 1$(element).on(type,[selector],[data],fn); 再看 delegate 的源码： 123function(selector, types, data, fn) &#123; return this.on( types, selector, data, fn ); &#125; 与 on 方法的唯一区别就是不能省略 selector 参数，其实从这个函数名就可以看的出来：delegate（委托），调用 delegate 方法的 element 就是被委托的元素，绑定了事件处理程序，而 selector 是触发事件的元素。 123$("#uList").delegate("li","click",getText);// 点击列表元素 1// 列表元素1 比较官方推荐尽量使用 on 方法，其他三种方法也是调用了 on 方法。 bind 方法：优点是清晰，直接，适合于将事件和事件处理程序直接绑定在单独的元素上，而缺点就是，不能将事件处理程序绑定到页面上的其他元素（也就是不能进行事件代理）。 live 方法：已经被弃用了就不多说了，将所有事件都委托到根节点上，根节点负担太大，并且在 DOM 节点较为复杂时会有意料之外的结果。 delegate 方法：相比于 live 方法而言，可以指定代理元素，速度比 live 方法要快，但相比与 bind 方法，还是要慢的，因为要冒泡到代理元素上再执行事件处理程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件模型系列（三）事件对象]]></title>
      <url>%2F2017%2F04%2F05%2FJavaScript%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[定义在触发事件时，会产生一个事件对象 event，这个对象包含着所有与事件有关的信息，例如一个鼠标点击事件对象就包括鼠标的位置信息，事件的类型，触发事件的元素等信息。 具体事件对象具体看一个键盘键入事件对象的所有属性： 一个事件对象根据事件类型的有很多很多属性，然而我们关注的对象属性是事件类型、事件目标、阻止事件冒泡、阻止事件默认行为等。 事件对象的重点属性和方法事件的目标这一属性表示事件的实际目标，比如我们点击一个按钮，target 返回整个按钮标签。注在 IE 浏览器中表示事件的目标的属性是 srcElement。 1234567&lt;button id="btn"&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;button id="btn"&gt;Click Me&lt;/button&gt;&#125;,false); 在非 IE 浏览器中的事件对象中，还有一个 currentTarget 属性，在事件处理程序内部，this 始终等于 currentTarget 的值，表示事件处理程序当前正在处理事件的那个元素。比如在下面的列表中： 12345&lt;ul id="uList"&gt; &lt;li id="list1"&gt;List one&lt;/li&gt; &lt;li id="list2"&gt;List Two&lt;/li&gt; &lt;li id="list3"&gt;List Three&lt;/li&gt;&lt;/ul&gt; 如果我们将事件处理程序绑定到 li 中，点击 li，this，target，currentTatget 三者均表示该 li。 1234567var list1 = document.getElementById("list1");list1.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.currentTarget); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.target == event.currentTarget); // true console.log(event.currentTarget == this); // true&#125;,false); 如果将事件处理程序绑定到 ul 中，点击 li，this 和 currentTarget 表示 ul，target 表示 li。 1234567var uList = document.getElementById("uList");uList.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.currentTarget); // &lt;ul id="uList"&gt;...&lt;/ul&gt; console.log(event.target == event.currentTarget); // false console.log(event.currentTarget == this); // true&#125;,false); 事件类型event.type 没什么好说的，就是获取触发元素的事件类型。 取消事件的进一步捕获或冒泡DOM 事件流： stopPropagation()：取消事件的进一步捕获或冒泡，如果 bubbles（表示事件是否冒泡）属性为 true 可以使用这个方法。 stopImmediatePropagation()：取消事件进一步捕获或冒泡，同时阻止任何事件处理程序被调用。 IE 事件流： cancelBubble，默认值为 false，设置为 true 取消事件冒泡，与 stopPropagation() 作用相同。 stopPropagation() 的使用，有一个前提，就是 bubbles 属性为 true。并且 stopPropagation() 除了阻止事件的冒泡还阻止了事件的捕获，就是说阻止了事件的进一步传播。 12345678910111213141516171819202122&lt;div id="superDiv" name="superDiv" value="hello"&gt; &lt;div id="subDiv"&gt;&lt;/div&gt;&lt;/div&gt;superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式"); event.stopPropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式");&#125;,false);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 冒泡模式");&#125;,false);// superDiv 捕获模式 点击 subDiv，输出结果只有捕获模式下的 superDiv，后续的事件捕获和冒泡都被阻止了。 发现一个问题就是，元素不管是在捕获还是冒泡模式下，都可以使用 stopPropagation()，然后打印出捕获模式下的事件对象的 bubbles 属性发现是 true。个人认为，不管是在捕获还是冒泡模式下，bubbles 的值除非设置为 false，默认值都是 true。 与 stopPropagation() 不同的是，stopPropagation() 可以阻止事件进一步传播，但是不能阻止该元素上绑定的其他函数的执行。比如我们在元素绑定了函数 1 和函数 2，我们在函数 1 上使用了stopPropagation()，那函数 2 还是会执行，但用 stopImmediatePropagation() 就不会了，它会阻止元素上绑定的所有事件处理函数执行。 123456789101112131415superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式-函数1"); event.stopPropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式-函数2");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);// superDiv 捕获模式-函数1// superDiv 捕获模式-函数2 使用 event.stopPropagation() 方法，会阻止事件进一步冒泡或捕获，不会阻止该元素上绑定的其他函数的执行。 1234567891011121314superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式-函数1"); event.stopImmediatePropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式-函数2");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);// superDiv 捕获模式-函数1 使用 event.stopImmediatePropagation() 不但会阻止事件的进一步冒泡或捕获，也会阻止该元素上绑定的其他函数执行。 在 IE 事件流中，cancelBubble属性 的作用与 stopPropagation() 方法相同。 1event.cancelBubble = true; // 阻止进一步冒泡 取消事件的默认行为在使用 JavaScript 编程时会遇到一个问题，就是当你给html添加事件时，由于浏览器默认的事件触发机制，可能会触发你不想触发的行为，例如，当点击提交按钮时会对表单进行提交，点击链接时会跳转到指定页面。 在 DOM 事件流中，调用事件对象的 preventDefault() 方法，在 IE 事件流中，设置事件对象的 returnValue 属性值为 false。 123DOM：preventDefault()IE：returnValue = false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件模型系列（二）事件流与事件代理]]></title>
      <url>%2F2017%2F04%2F03%2FJavaScript%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[事件流定义为什么会有事件流这个概念呢？ 我们想象一组同心圆，当你点击圆心的时候，实际上，你点击了所有圆。就比如你点击了页面中的一个按钮，同时你也点击了这个按钮的父容器，因为这个按钮是属于这个容器的，然后一层一层向上，可以说你也点击了这个页面。因此我们需要确定这些元素接受事件的先后顺序。 因此事件流的定义其实就是，从页面中接受事件的顺序。 在处理事件流的时候，IE 和 Netscape 采取了两种截然不同的处理方式。 事件冒泡（event bubbling）：IE事件流事件冒泡是指从最具体的元素开始，逐级向上传播直到 document。123456789101112131415161718192021222324&lt;div id="superDiv"&gt;superDiv &lt;div id="subDiv"&gt;subDiv&lt;/div&gt;&lt;/div&gt;document.addEventListener("click",function() &#123; console.log("document 冒泡模式");&#125;,false);superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式");&#125;,false);subDiv.addEventListener("click",function(event) &#123; console.log("subDiv 冒泡模式");&#125;,false);// 点击 subDiv// subDiv 冒泡模式// superDiv 冒泡模式// document 冒泡模式// 点击 superDiv// superDiv 冒泡模式// document 冒泡模式 在冒泡模式下，点击 subDiv，subDiv（作为最具体的元素）接收到事件，执行事件处理程序，打印 subDiv 冒泡模式，执行完毕后，冒泡到上一级元素，执行 superDiv 的事件处理程序，打印 superDiv 冒泡模式，直到 document。 在冒泡模式下，点击 superDiv，则不会执行 subDiv 的事件绑定程序，向上冒泡到 document。 事件捕获（event capturing）与事件冒泡相反，事件最开始由不太具体的节点接受，最具体的节点最后接受。 DOM 事件流为了天下一统的局面，DOM 事件流中既包含了事件冒泡也包含了事件捕获。 DOM 事件流分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获阶段： 事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 处于目标阶段： 事件到达目标元素, 触发目标元素的监听函数。 事件冒泡阶段： 事件从目标元素向上传播到 document，冒泡前进，遇到事件监听函数则执行。 12345678910111213141516&lt;div id="superDiv"&gt; &lt;div id="subDiv"&gt;&lt;/div&gt;&lt;/div&gt;superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式"); &#125;,true); superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式"); &#125;,false); subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式"); &#125;,true); subDiv.addEventListener("click",function() &#123; console.log("subDiv 冒泡模式"); &#125;,false); 执行结果： 对于 DOM 事件流，我们要明确一点，在给一个元素或文档绑定事件时，通常使用捕获或者冒泡的一种。在 DOM 事件流中，我们可以设置这个事件处理程序是在捕获阶段发生还是在冒泡阶段发生，这个元素上的事件只会触发一次。 事件代理事件代理，又叫事件委托，就是将应该加在某个元素上的事件处理程序，（委托）加到其他的元素上，完成这个事件。 最常见的就是将原本需要绑定在子类元素上的事件处理程序，（委托）绑定到父类元素上。通过父类元素上的事件处理程序管理所有子类事件。 比如说，有一个 ul 列表，里面有很多的 li 列表项，点击不同的 li，执行不同的事件处理函数，我们就需要给每一个 li 列表项绑定事件处理程序，这样会造成代码整体性能下降，因为事件处理程序是一个函数，函数是对象，对象都是保存在堆中的（内存中），内存中的对象越多，性能越差。 根据事件流模型，我们点击了 li 列表项，同时也点击了 ul 列表，再根据事件冒泡原理，事件从 li 向上传播到 ul，我们将事件处理程序绑定的 ul 上，再结合事件对象对 li 进行相同或不同的处理。 12345678910111213141516171819202122232425&lt;ul id="myLinks"&gt; &lt;li id="goSomewhere"&gt;Go Somewhere&lt;/li&gt; &lt;li id="doSomething"&gt;Do Soemthing&lt;/li&gt; &lt;li id="sayHi&gt;Say Hi&lt;/li&gt;&lt;/ul&gt;var list = document.getElementById("myLinks");addHandler(list,"click",function(event) &#123; // 结合事件对象实现事件委托 event = getEvent(event); var target = getTarget(event); switch() &#123; case "goSomewhere": location.href = "http://www.wrox.com"; break; case "doSomething": document.title = "I change the document's title"; break; case "sayHi": alert("hi"); break; &#125;&#125;); 优点： 提高性能，可以大量节省内存占用，减少事件注册 新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适 缺点： 滥用可能出现事件误判，即本不该应用触发事件的元素被绑定上了事件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件模型系列（一）事件与事件处理程序]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[基本定义事件： 事件就是浏览器或者用户执行的某种动作，比如文档加载完毕（load）、鼠标点击（click）等等。 事件处理程序： 事件处理程序是响应事件的函数。事件处理程序可以看做是动作的结果，比如文档加载完毕或者点击鼠标之后会发生什么。 为一个事件添加事件处理程序有四种方式。分别为：HTML、DOM0级、DOM2级、IE。 事件处理程序HTML 事件处理程序最开始学习 JavaScript 的时候，用到的就是 HTML 事件处理程序，就是直接在 HTML 代码中添加事件处理程序。 比如直接在 HTML 标签内添加： 1&lt;button id="btn" onclick="console.log('clicked');"&gt;Click Me&lt;/button&gt; 或添加到 script 标签中（外部 js 文件）： 123456&lt;button id="btn" onclick="show();"&gt;&lt;/button&gt;&lt;script&gt; function show() &#123; console.log("clicked"); &#125;&lt;/script&gt; 优点： 123&lt;button id="btn" onclick="console.log(event.type);"&gt;Click Me&lt;/button&gt; // click &lt;button id="btn" onclick="console.log(this.id);"&gt;Click Me&lt;/button&gt; // btn 可以通过 event 函数直接访问事件对象，比如 event.type 在函数内部，this 指向事件的目标元素，在上面第二行代码中，this 指向的就是这个 button 元素 事件处理程序中的代码在执行时，有权访问到全局作用域中的任何代码，这就是为什么我们可以把函数定义在 script 中，同样也可以调用 缺点： 时差问题： 用户可能在 HTML 元素一出现就触发事件，而此时该事件的脚本可能还没有加载完成 HTML 与 JavaScript 代码紧密耦合 DOM0 级事件处理程序将一个函数赋值给一个事件处理程序属性。比如： 123456&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.onclick = function() &#123; console.log("clicked");&#125; 在 DOM0 级事件处理程序中，this 指向的是这个对象。 优点： HTML 与 JavaScript 代码联系不紧密。 缺点： 不能给一个元素同时添加多个相同的事件处理程序，后添加的事件事件处理程序会覆盖之前的。 1234567btn.onclick = function() &#123; console.log("clicked1");&#125;btn.onclick = function() &#123; console.log("clicked2");&#125;// clicked2 DOM2级事件处理程序DOM2 级事件处理程序用到的是 addEventListenter 方法。 1element.addEventListener(type,handler,ture/false); 注意在 DOM2 级事件处理程序中，type 是不带 on 的，handler 是事件处理函数，true 表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用。 1234567&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function() &#123; console.log("clicked");&#125;,false); // 冒泡阶段调用 移除：通过 addEventListenter() 添加的事件处理程序，只能通过 removeEventListenter() 移除。 12345var handler = function() &#123; console.log("clicked");&#125;btn.addEventListener("click",handler,false); // 添加btn.removeEventListener("click",handler,false); // 移除 优点： 可以一个事件添加多个事件处理程序 浏览器支持性好 HTML 与 JavaScript 代码联系不紧密 123456789101112&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function() &#123; console.log("clicked1");&#125;,false);btn.addEventListener("click",function() &#123; console.log("clicked2");&#125;,false);// clicked1 clicked2 缺点： 通过 addEventListenter() 添加的匿名函数无法移除 IE8 及以下版本不支持该方法 IE事件处理程序与 DOM2 级事件处理程序类似，IE 提供了 attachEvent() 和 detachEvent() 方法。不同之处在于，IE 事件处理程序只在冒泡阶段触发。 1element.attachEvent(type,handler); 注意 IE 事件处理程序，type 要带 on，handler 是事件处理函数。 12345var handler = function() &#123; console.log("clicked");&#125;btn.attachEvent("onclick",handler); // 添加btn.detachEvent("onclick",handler); // 移除 优点： 可以一个事件添加多个事件处理程序 HTML 与 JavaScript 代码联系不紧密 缺点： 只有 IE 和 Opera 支持。 跨浏览器事件处理程序为了兼容所有浏览器，我们可以封装一个事件处理程序： 12345678910111213141516171819202122232425// 绑定事件var addHandler = function(element,type,handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type,handler,false); &#125; else if (element.attachEvent)&#123; element.attachEvent("on"+type,handler); &#125; else &#123; element["on"+type]=handler; &#125;&#125;// 移除事件var reomoveHandler = function(element,type,handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type,handler,false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on"+type,handler); &#125; else &#123; element["on"+type]=null; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网易 2017 春招笔试编程题]]></title>
      <url>%2F2017%2F04%2F01%2F%E7%BD%91%E6%98%93%202017%20%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
      <content type="text"><![CDATA[消除重复元素题目描述小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难，希望你来帮助他。 输入包括两行： 第一行为序列长度n(1 ≤ n ≤ 50)。 第二行为n个数sequencei，以空格分隔。 输入例子： 9 100 100 100 99 99 99 100 100 100 输出消除重复元素之后的序列，以空格分隔，行末无空格。 输出例子： 99 100 思路输入是一个可能包含有多个重复元素的数组（inputArr）： 用一个数组（noRepeatArr）存储输入数组中独立的元素，就是一个输入数组去重的过程； 将所有元素最后出现的索引值存在一个数组中（index），用到 arr.lastIndexOf(element) 方法； 将 index 数组从小到大排序，按排好序的索引值从输入数组中取出相应元素即可。 代码123456789101112131415161718192021function findLastPosition(inputArr) &#123; var noRepeatArr = []; var inputLen = inputArr.length; var index = []; var outputArr = []; for (var i = 0; i &lt; inputLen; i++) &#123; if (noRepeatArr.indexOf(inputArr[i])==-1) &#123; // noRepeat中没有该元素 noRepeatArr.push(inputArr[i]); &#125; &#125; for (var j = 0; j &lt; noRepeatArr.length; j++) &#123; index.push(inputArr.lastIndexOf(noRepeatArr[j])); &#125; index.sort(function(a,b) &#123; return a-b; &#125;); for (var k = 0; k &lt; index.length; k++) &#123; outputArr.push(inputArr[index[k]]); &#125; return outputArr;&#125; 奇怪的表达式求值题目描述常规的表达式求值，我们都会根据计算的优先级来计算。比如 / 的优先级就高于 + -。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有 /，只有+，- 和 。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入为一行字符串，即一个表达式。其中运算符只有 -，+，*。参与计算的数字只有 0-9。 输出一个数，即表达式的值。 输入例子: 3+5*7 输出例子: 56 思路考虑到数字只有0-9，先取出字符串的前三个字符（str.substring），计算出这三个字符的值（eval函数），然后再用一个循环每次取后两个字符加入计算。 代码1234567function strangeExpression(inputExpStr) &#123; var result = eval(inputExpStr.substring(0,3)); for (var i = 3; i &lt; inputExpStr.length; i+=2) &#123; result = eval(result + inputExpStr.substring(i,i+1)); &#125; return result;&#125; 集合题目描述小易最近在数学课上学习到了集合的概念，集合有三个特征：1. 确定性；2. 互异性；3. 无序性。 小易的老师给了小易这样一个集合：S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z } 需要根据给定的w，x，y，z，求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题，需要你来帮助他。 输入包括一行：一共4个整数分别是w(1 ≤ w ≤ x)，x(1 ≤ x ≤ 100)，y(1 ≤ y ≤ z)，z(1 ≤ z ≤ 100)，以空格分隔。 输出描述：输出集合中元素的个数。 输入例子: 1 10 1 1 输出例子: 10 代码12345678910111213141516function eleNumInSet(w,x,y,z) &#123; var sAll = []; var s = []; for (var i = w; i &lt;= x; i++) &#123; // p 集合 for (var j = y; j &lt;= z; j++) &#123; // q 集合 sAll.push(i/j); &#125; &#125; // 去重 for (var k = 0; k &lt; sAll.length; k++) &#123; if (s.indexOf(sAll[k])==-1) &#123; s.push(sAll[k]); &#125; &#125; return s.length;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FCC Basic Algorithm Scripting 基础算法集]]></title>
      <url>%2F2017%2F03%2F31%2FFCC%20Basic%20Algorithm%20Scripting%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%9B%86%2F</url>
      <content type="text"><![CDATA[前言本文为 FreeCodeCamp 中前端的十六道基础算法题。 Reverse a String 翻转字符串★ 具体步骤 字符串 –&gt; 数组：str.split(“连接符”) 翻转数组：arr.reverse()，本方法直接改变原数组 数组 –&gt; 字符串：arr.join(“连接符”) ★ 代码123456789function reverseString(str) &#123; var arr = new Array(); arr = str.split(""); arr.reverse(); str = arr.join(""); return str;&#125;reverseString("hello"); // olleh Factorialize a Number 计算一个整数的阶乘★ 具体步骤 分情况：if 判断 n=0，n&gt;0 循环计算：n=0 时，n!=1，n&gt;0 时，循环累乘 n!=1×2×···×n ★ 代码1234567891011121314function factorialize(num) &#123; var sum = 1; if (num == 0) &#123; sum = 1; &#125; else &#123; for (var i = 1; i &lt;= num; i++) &#123; sum = sum * i; &#125; &#125; return sum;&#125;factorialize(5); // 120 Check for Palindromes 判断回文★ 要求 回文（palindrome）：一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，例如 eye。 如果给定的字符串是回文，返回 true，反之，返回 false。 ★ 思路去掉字符串多余的标点符号和空格，然后把字符串转化成小写，翻转之后检查是否与原字符串相等。 ★ 具体步骤 用正则表达式找到字符串多余的标点符号和空格（找出字母和数字即可） 去除非字母数字符号：str.replace(被替换部分,替换部分) 将字符串转为小写：str.toLowerCase() 将字符串翻转：见第一题 判断翻转后的字符串与原来的是否相同 正则表达式：用来匹配字符串中字符组合的模式。其中 W 表示字母、数字、下划线，因此 [\W_] 就可以表示非字母数字了，也可以用 [^A-Za-z0-9] 表示 ★ 代码12345678function palindrome(str) &#123; var re = /[\W_]/g; var newStr = str.replace(re,"").toLowerCase(); // 纯字母数字的小写形式 var reverseStr = newStr.split("").reverse().join(""); return reverseStr == newStr;&#125;palindrome("eye"); // true Find the Longest Word in a String 找到提供的句子中最长的单词，并计算它的长度★ 思路将字符串转为数组，记录下每个数组元素的长度，将长度排序。 ★ 具体步骤 将字符串转为数组：split() 循环：将每个数组元素的长度保存在新数组中 排序：将长度数组排序 sort()，得到最大长度值 ★ 代码123456789101112131415161718function findLongestWord(str) &#123; var arr = new Array(); var arrLen = new Array(); arr = str.split(" "); for (var i = 0; i &lt; arr.length; i++)&#123; arrLen[i] = arr[i].length; &#125; arrLen.sort(function(a,b) &#123; return b-a; &#125;); return arrLen[0];&#125;findLongestWord("The quick brown fox jumped over the lazy dog"); // 6 Title Case a Sentence 字符串的单词首字母大写其余小写★ 思路先将所有字母统一为小写，再将字符串转化为数组，将每一个数组元素的第一个字符变为大写。 ★ 具体步骤 转小写：将字符串中所有字母转为小写 str.toLowerCase() 字符串 –&gt; 数组：str.split() 遍历数组，将每个数组元素第一个字母替换为大写 遍历 arr.map() 替换 arr.replace() 单字符 arr.charAt(index) 大写 toUpperCase() 数组 –&gt; 字符串：arr.join() ★ 代码123456789101112131415161718function titleCase(str) &#123; str = str.toLowerCase(); var arr = new Array(); arr = str.split(" "); var newArr = new Array(); newArr = arr.map(toUpper); function toUpper(element) &#123; return element.replace(element.charAt(0),element.charAt(0).toUpperCase()); &#125; str = newArr.join(" "); return str;&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot Return Largest Numbers in Arrays 将小数组们的最大值串联成新数组★ 要求大数组中包含了若干个小数组，分别找到每个小数组中的最大值（数值的最大值），然后把它们串联起来，形成一个新数组。 ★ 具体步骤 先把大数组分为若干小数组 循环小数组中每一个元素 找到每个小数组中的最大值 用新数组存储最大值 ★ 代码1234567891011121314151617function largestOfFour(arr) &#123; var newArr = new Array(); for (var i = 0; i &lt; arr.length; i++) &#123; var max = arr[i][0]; // max 要定义在内层循环外 for (var j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] &gt;= max) &#123; max = arr[i][j]; &#125; &#125; newArr[i] = max; &#125; return newArr;&#125;largestOfFour([[4,5,1,3],[13,27,18,26],[32,35,37,39],[1000,10001,857,1]]); // [5,27,39,10001] Confirm the Ending 检查一个字符串是否以指定的字符串结尾★ 思路首先要知道指定字符串 target 的个数，找到待检查字符串中最后几位，判断两者是否相等。 ★ 具体步骤str.substr(beginindex,endindex) 方法：返回字符串从指定位置开始，到指定长度的字符串。 ★ 代码12345function confirmEnding(str,target) &#123; return target == str.substr(str.length-target.length,target.length);&#125;confirmEnding("Bastian","n"); // true Repeat a string repeat a string 重要的事情说3遍★ 要求重复一个指定的字符串 num 次，如果 num 是一个负数则返回一个空字符串。 ★ 具体步骤 保留原始字符串：var newStr = str 循环 ★ 代码1234567891011121314function repeat(str,num) &#123; var newStr = str; if (num &gt; 0) &#123; for (var i = 0; i &lt; num; i++) &#123; newStr = newStr.concat(str); &#125; &#125; else &#123; newStr = ""; &#125; return newStr;&#125;repeat("abc",3); // abcabcabcabc Truncate a string 用瑞兹来截断对面的退路★ 要求如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度 ★ 思路最开始要判断 num 是否大于字符串长度。 当 num 小于字符串长度时，分 num 小于等于 3 和大于 3 的情况； 当 num&lt;=3 时，直接在字符串后面加三个点； 当 num&gt; 3时，字符串 + 三个点的长度 = num。 ★ 具体步骤 num&lt;=3：str.slice()、str.concat(“…”) num&gt;3：str.slice()、str.concat(“…”) ★ 代码12345678910111213141516171819function truncate(str,num) &#123; var newStr; if (num &lt; str.length) &#123; if (num &lt;= 3) &#123; newStr = str.slice(0,num); newStr = newStr.concat("..."); &#125; else &#123; newStr = str.slice(0,num-3); newStr = newStr.concat("..."); &#125; &#125; else &#123; newStr = str; &#125; return newStr;&#125;truncate("A-tisket a-tasket A green and yellow basket","A-tisket a-tasket A green and yellow basket".length+2); // A-tisket a-tasket A green and yellow basket Chunky Monkey 猴子吃香蕉可是掰成好几段来吃哦★ 要求把一个数组 arr 按照指定的数组大小 size 分割成若干个数组块。 ★ 思路将分割出的数组块当作一个个数组元素存在一个新的数组中，要确定分割的个数，才好循环。 ★ 具体步骤设定切割起始位置 begin 与 end，并按照 size 大小累加，将切下的数组块循环 push 进新数组中。 arr.slice(beginindex,endindex)，切割时包括 beginindex，不包括 endindex。 注意 arr.push() 返回的是长度值。 ★ 代码123456789101112131415function chunk(arr,size) &#123; var newArr = new Array(); var begin = 0; var end = size; for (var i = 0; i &lt; arr.length/size; i++) &#123; newArr.push(arr.slice(begin,end)); begin = begin + size; end = end + size; &#125; return newArr;&#125;chunk(["a","b","c","d","e"],2); // [["a","b"],["c","d"]["e"]] Slasher Flick 打不死的小强★ 要求返回一个数组被截断 n 个元素后还剩余的元素，截断从索引 0 开始（删除数组前 n 个元素） ★ 具体步骤1array.splice(start, deleteCount[, item1[, item2[, ...]]]) start 为开始索引值，deleteCount 为整数，表示要移出的元素个数，item1 表示要添加的元素，若无，则函数只删除元素。函数返回被删除元素数组。 ★ 代码12345function slasher(arr,howMany) &#123; return arr.splice(howMany,arr.length-howMany);&#125;slasher([1,2,3],2); // [3] Mutations 蛤蟆可以吃队友，也可以吃对手★ 要求如果数组第一个字符串元素包含了第二个字符串元素的所有字符，忽略顺序和大小写，函数返回 true。 例如：[&quot;hello&quot;, &quot;hey&quot;] 应该返回 false，因为字符串 &quot;hello&quot; 并不包含字符 &quot;y&quot; 再例如：[&quot;Alien&quot;, &quot;line&quot;] 应该返回 true，因为 &quot;line&quot; 中所有字符都可以在 &quot;Alien&quot; 找到 ★ 思路首先要将两个字符串统一为小写，再看第二个字符串中的所有元素是不是都能在第一个字符串中找到。 ★ 具体步骤 数组-&gt;字符串：个数较少，直接用下标赋值 字符串转小写：str.toLowerCase() 第二个字符串 –&gt; 数组：str.split() 检查第二个字符串中的每个字符是否都能在第一个字符串中找到 ★ 代码12345678910111213141516171819function mutation(arr) &#123; var str1 = arr[0].toLowerCase(); var str2 = arr[1].toLowerCase(); var arr2 = new Array(); arr2 = str2.split(""); for (var i = 0; i &lt; arr2.length; i++) &#123; if (str1.indexOf(arr2[i]) == -1) &#123; return false; &#125; else &#123; continue; &#125; &#125; return true;&#125;mutation(["hello","hey"]); // false Falsy Bouncer 真假美猴王★ 要求删除数组中的所有假值。 在JavaScript中，假值有 false、null、0、””、undefined 和 NaN ★ 思路遍历数组，判断是否为假值，是则删除，否则留下。 ★ 具体步骤 遍历数组：arr.filter() 判断是否为假值：Boolean(element)。element 为假值返回 false，真值返回 true ★ 代码123456789function bouncer(arr) &#123; var newArr = arr.fliter(delFalsy); function delFalsy(element) &#123; return Boolean(element); &#125; return newArr;&#125;bouncer([7,"ate","",false,9]); // [7,"ate",9] Seek and Destroy 金克斯的迫击炮★ 要求实现一个摧毁 destroyer 函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 例如：destroyer([1, 2, 3, 1, 2, 3], 2, 3) 应该返回 [1, 1] ★ 思路遍历数组，将与待摧毁值相同的数组元素删除。 ★ 具体步骤 将待摧毁值存入一个数组中：arguments[index] 遍历数组：arr.filter() 判断是否要摧毁：循环+判断 ★ 注意 filter 是根据其函数返回值判断是否保留该元素，true 为保留，false 为删除。注意循环的结束与跳过情况 arguments[index] 不要放在内部函数中，这样将取不到外部函数的参数 循环中最好不要调用函数 ★ 代码12345678910111213141516171819202122232425262728293031function destroyer() &#123; var arr = arguments[0]; var a = new Array(); var num = arguments.length; var j = 0; for (var i = 1; i &lt; num; i++) &#123; a[j] = arguments[i]; // 待摧毁数组 j++; &#125; var newArr = arr.filter(destroy); function destroy(element) &#123; for (var k = 0; k &lt; num-1; k++) &#123; var res; if (element == a[k]) &#123; res = false; break; &#125; else &#123; res = true; continue; &#125; return res; &#125; return newArr; &#125; &#125;destroyer([1,2,3,1,2,3],2,3); // [1,1] Where do I belong 我身在何处★ 要求先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 例如：where([1,2,3,4], 1.5) 返回 1 因为 1.5 插入到数组 [1,2,3,4] 后变成 [1,1.5,2,3,4]，而 1.5 对应的索引值就是 1 ★ 具体步骤 指定元素放入数组：arr.push() 数组排序：从小到大 arr.sort() 找到指定元素的索引：arr.indexOf() ★ 代码123456789function where(arr,num) &#123; arr.push(num); arr.sort(function(a,b) &#123; return a-b; // 从小到大 &#125;); return arr.indexOf(num);&#125;where([40,60],50); // 1 Caesars Cipher 让上帝的归上帝，凯撒的归凯撒（凯撒编码）★ 要求写一个 ROT13 函数，实现输入加密字符串，输出解密字符串。注意：所有的字母都是大写，不要转化任何非字母形式的字符（例如：空格，标点符号），遇到这些特殊字符，跳过它们。 ROT13：http://www.baike.com/wiki/ROT13&amp;prd=so_1_doc ★ 思路将 A-M 的 Unicode 值 +13，将 N-Z 的 Unicode 值-13。 ★ 具体步骤 得到字符串中每个字母的 Unicode(UTF16) 值：str.charCodeAt(index) 返回 0~65535 之间的整数 将 A-M 的 Unicode 值 +13，将 N-Z 的 Unicode 值 -13，其余字符不变 Unicode值 –&gt; 字母：String.fromCharCode(Unicode值) ★ 代码12345678910111213141516171819202122function rot13(str) &#123; var arr = new Array(); for (var i = 0; i &lt; str.length; i++) &#123; var utfNum = str.charCodeAt(i); if (utfNum &gt;= 65 &amp;&amp; utfNum &lt;= 90) &#123; if (utfNum &lt;= 77) &#123; utfNum += 13; &#125; else &#123; utfNum -= 13; &#125; &#125; arr[i] = String.fromCharCode(utfNum); &#125; str = arr.join(""); return str;&#125;rot13("SERR CVMMN!"); // "FREE PIZZA!"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Hexo 在 Github 上搭建个人博客]]></title>
      <url>%2F2017%2F03%2F30%2F%E4%BD%BF%E7%94%A8%20Hexo%20%E5%9C%A8%20Github%20%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[准备工作Node.js官网下载地址：https://nodejs.org/en/ 傻瓜式安装过程【略】 Github申请账号Github 官网：https://github.com/ 注册账号【略】 新建博客仓库New repository –&gt; 仓库名的格式必须为：用户名.github.io –&gt; 进入仓库后，点击 settings –&gt; 在Options 菜单栏中找到 GitHub Pages 选项 部分教程中，这个选项中有 Launch automatic page generator 按钮，此时直接点击就可以了。 但在我的 Github Page 页面中并没有这个选项，只有 Choose a theme 按钮，点进去会让你选择主题，同样也可以生成 Github Page，但此时是基于 Jekyll 框架的。 Git下载安装官网下载地址：https://git-scm.com/download/ 配置环境变量右击计算机 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 在系统变量中找到 path 变量，加入 Git 的两个路径： D:\Program Files\Git\bin D:\Program Files\Git\libexec\git-core 注意不同环境变量中不同路径要加分号（英文半角），libexec 文件夹不一定就在 Git 目录下，Git2.0 以上版本的在 Git 目录下的 mingw32 文件夹中。 关联 Github 账号随处右击进入 GitBash，输入命令行： 12git config --global user.name "用户名"git config --global user.email "邮箱地址" SSH Keys接着上一步，输入命令行： 1ssh-keygen -t rsa -C "邮箱地址" 连续回车，生成两个文件 id_rsa 和 id_rsa.pub，打开 id_rsa.pub 复制所有内容。 登录网页版 Github，点击头像 –&gt; Settings –&gt; SSH and GPG keys –&gt; 点击 New SSH key 按钮 –&gt; Title随意，将刚刚复制的内容粘贴到 Key 中 –&gt; Add SSH Key 结束。 安装 Hexo进入 Node.js 的安装路径，新建一个文件夹（我这里取名为 blog），进入 blog 文件夹，打开命令行窗口（按住 Shift 键，鼠标右键，选择在此处打开命令窗口），依次输入命令： 安装 Hexo： 1npm install -g hexo 初始化： 1hexo init 生成静态界面： 1hexo g 启动本地服务，进行文章预览调试 1hexo s 此时在浏览器中输入 http://localhost:4000 可以看到这样的页面： 打开 D:\Program Files\nodejs\blog\source_posts 就可以看到一个 hello-world.md 的文件，这就是网站上显示的文章，之后写的博客都是以 md 格式存在这个文件夹中。 配置 Github打开 nodejs\blog 文件夹下的 _config.yml 文件，拉到最下面，修改为： 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 继续执行配置命令： 1hexo d 完成上述步骤之后，在浏览器中输入 http://用户名.github.io 就可以了。 部署步骤每次部署的步骤，可以按以下三步进行： 12345hexo cleanhexo generate // hexo ghexo deploy // hexo d 更换 Hexo 主题我使用的主题是：https://github.com/iissnan/hexo-theme-next 打开主题所在文件夹 nodejs\blog\themes，打开 GitBsh 或者命令行，输入下载主题命令: 1git clone https://github.com/iissnan/hexo-theme-next.git 再执行命令（没有执行如下命令会报错） 12npm install hexo-renderer-jade --savenpm install hexo-renderer-sass --save 下载完成后，会看到 themes 下多了一个文件夹，修改文件名为 next，修改 nodejs\blog 文件夹下的 _config.yml 文件，将 theme 值修改为：next，注意 theme 冒号后的空格要保留。 再次执行命令: 12hexo ghexo d 就可以看到主题更换成功了。 报错信息处理报错 spawn git ENOENT在配置 Github 中最后输入 hexo d 后报错 spawn git ENOENT 解决方法： 添加 Git 环境变量，还不行的话将 Git 版本退回到 2.0 以下。 报错 not a git repository解决了上一个报错之后，出现 not a git repository 报错信息 解决方法： 删除 nodejs\blog 文件夹下的 .deploy_git 文件夹并且执行 hexo clean 后，重新 hexo g 和 hexo d。 报错 Cannot find module ‘hexo-util’更换完主题之后，再次执行 hexo clean 时报错，报错信息： 解决方法： 重新安装 hexo-util 模块即可，在 \nodejs\blog 下输入命令：1npm install -- save-dev hexo-util 关于 Hexo 的更多设置添加评论系统我使用的评论系统是：disqus。 注册账号disqus 官网地址：https://disqus.com 添加网址在设置过程中会需要填你的网站地址，填入 https://用户名.github.io 即可 找到 short_name由于在最初设置的时候没注意 Choose your unique Disqus URL 这一栏填的是什么，其实这一栏中的内容就是你的 short_name，在你的用户界面点击 Settings 菜单栏。 修改文件打开根目录（nodejs\blog）下的 _config.yml 文件，在最后面添加： 1disqus_shortname: your_disqus_short_name 再打开 nodejs\blog\themes\next，找到 _config.yml 文件，找到如下代码修改完即可： 首页文章只显示预览修改文件目录：nodejs\blog\themes\next，找到 _config.yml 文件，找到如下代码： 将 false 修改为 true 即可。]]></content>
    </entry>

    
  
  
</search>
