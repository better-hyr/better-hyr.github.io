<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript事件模型系列（四）jQuery中的事件模型]]></title>
      <url>%2F2017%2F04%2F06%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89jQuery%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[前言jQuery中提供了四种事件绑定方式，分别是bind、live、delegate、on，对应的解除监听的函数分别是unbind、die、undelegate、off。 先声明一个例子，各函数的用法将围绕这个例子。 12345678910111213&lt;ul id="uList"&gt; &lt;li id="list1" class="item"&gt;列表元素1&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素2&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素3&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素4&lt;/li&gt; &lt;li id="list1" class="item"&gt;列表元素5&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; function getText() &#123; console.log(this.innerHTML); &#125;&lt;/script&gt; 原理on1$(element).on(type,[selector],[data],fn); type：事件类型（不带 on，打引号） selector：可选，触发事件的元素，若没有设置则默认为 element data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 data 参数的使用：1234567// 附加数据可以为任意类型var userObj = &#123; name: "Echo", age: 18 &#125;;// 为所有p元素绑定click事件，并传入附加数据(user)$("p").on( "click", userObj, function(event)&#123; console.log(event.data.name); // Echo&#125; ); 我们看到前有调用 on 的元素 element，后有函数参数 selector，那么二者之间的关系是什么呢，我们先不设置 selector，那么事件处理程序和事件都会默认绑定在 element 上。 1$("#uList").on("click",getText); 再将 selector 设置为 li 时， 123$("#uList").on("click","li",getText);// 点击列表元素 1// 列表元素1 这样看，还有点事件委托的意味，调用该方法的元素 element 绑定了事件处理程序，而参数中的 selector 才是触发事件的元素。 bind1$(element).bind(type,[data],fn); type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 在最开始学 jQuery 的时候，用的最多的就是 bind 方法。来看 bind 的源码： 123function (types, data, fn) &#123; return this.on (types, null, data, fn);&#125; 可以看到 bind 是调用了 on 方法，并设置 selector 属性为 null。1$("#uList").bind("click",getText); 123$("#list1").bind("click",getText);// 点击列表元素 1// 列表元素1 live1$(element).live(type,[data],fn); type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 live 源码： 1234function (types, data, fn) &#123; jQuery (this.context).on(types, this.selector, data, fn); return this;&#125; live 方法其实也是调用了 on 方法，但不是绑定到调用的元素上，而是绑定到 this.context，那 context 又是什么呢，我个人认为就是该元素的上下文，在可以使用 live 方法的 jQuery 版本下： 12$("#uList").context; // #document"#list1").context; // #document 而在 jQuery1.7 以上版本： 12$("#uList").context; // undefined$("#list1").context; // undefined 因此这就导致了一个弊端，将所有事件都委托到根节点上，根节点负担太大，并且在 DOM 节点较为复杂时会有意料之外的结果，所以 jQuery1.7 之后就废弃了 live 方法。 1$("#uList").live("click",getText); 123$("#list1").on("click",getText);// 点击列表元素 1// 列表元素1 delegate1$(element).delegate(selector,type,[data],fn); selector：触发事件的元素 type：事件类型（不带 on，打引号） data：可选，返回绑定当前事件处理程序时，传递的附加数据，通过 event.data 调用 fn：事件处理程序，可传入事件对象 对于一下 on 方法： 1$(element).on(type,[selector],[data],fn); 再看 delegate 的源码： 123function(selector, types, data, fn) &#123; return this.on( types, selector, data, fn ); &#125; 与 on 方法的唯一区别就是不能省略 selector 参数，其实从这个函数名就可以看的出来：delegate（委托），调用 delegate 方法的 element 就是被委托的元素，绑定了事件处理程序，而 selector 是触发事件的元素。 123$("#uList").delegate("li","click",getText);// 点击列表元素 1// 列表元素1 比较官方推荐尽量使用 on 方法，其他三种方法也是调用了 on 方法。 bind 方法：优点是清晰，直接，适合于将事件和事件处理程序直接绑定在单独的元素上，而缺点就是，不能将事件处理程序绑定到页面上的其他元素（也就是不能进行事件代理）。 live 方法：已经被弃用了就不多说了，将所有事件都委托到根节点上，根节点负担太大，并且在 DOM 节点较为复杂时会有意料之外的结果。 delegate 方法：相比于 live 方法而言，可以指定代理元素，速度比 live 方法要快，但相比与 bind 方法，还是要慢的，因为要冒泡到代理元素上再执行事件处理程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件模型系列（三）事件对象]]></title>
      <url>%2F2017%2F04%2F05%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[定义在触发事件时，会产生一个事件对象 event，这个对象包含着所有与事件有关的信息，例如一个鼠标点击事件对象就包括鼠标的位置信息，事件的类型，触发事件的元素等信息。 具体事件对象具体看一个键盘键入事件对象的所有属性： 一个事件对象根据事件类型的有很多很多属性，然而我们关注的对象属性是事件类型、事件目标、阻止事件冒泡、阻止事件默认行为等。 事件对象的重点属性和方法事件的目标这一属性表示事件的实际目标，比如我们点击一个按钮，target 返回整个按钮标签。注在 IE 浏览器中表示事件的目标的属性是 srcElement。 1234567&lt;button id="btn"&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;button id="btn"&gt;Click Me&lt;/button&gt;&#125;,false); 在非 IE 浏览器中的事件对象中，还有一个 currentTarget 属性，在事件处理程序内部，this 始终等于 currentTarget 的值，表示事件处理程序当前正在处理事件的那个元素。比如在下面的列表中： 12345&lt;ul id="uList"&gt; &lt;li id="list1"&gt;List one&lt;/li&gt; &lt;li id="list2"&gt;List Two&lt;/li&gt; &lt;li id="list3"&gt;List Three&lt;/li&gt;&lt;/ul&gt; 如果我们将事件处理程序绑定到 li 中，点击 li，this，target，currentTatget 三者均表示该 li。 1234567var list1 = document.getElementById("list1");list1.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.currentTarget); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.target == event.currentTarget); // true console.log(event.currentTarget == this); // true&#125;,false); 如果将事件处理程序绑定到 ul 中，点击 li，this 和 currentTarget 表示 ul，target 表示 li。 1234567var uList = document.getElementById("uList");uList.addEventListener("click",function(event) &#123; console.log(event.target); // &lt;li id="list1"&gt;List one&lt;/li&gt; console.log(event.currentTarget); // &lt;ul id="uList"&gt;...&lt;/ul&gt; console.log(event.target == event.currentTarget); // false console.log(event.currentTarget == this); // true&#125;,false); 事件类型event.type 没什么好说的，就是获取触发元素的事件类型。 取消事件的进一步捕获或冒泡DOM 事件流： stopPropagation()：取消事件的进一步捕获或冒泡，如果 bubbles（表示事件是否冒泡）属性为 true 可以使用这个方法。 stopImmediatePropagation()：取消事件进一步捕获或冒泡，同时阻止任何事件处理程序被调用。 IE 事件流： cancelBubble，默认值为 false，设置为 true 取消事件冒泡，与 stopPropagation() 作用相同。 stopPropagation() 的使用，有一个前提，就是 bubbles 属性为 true。并且 stopPropagation() 除了阻止事件的冒泡还阻止了事件的捕获，就是说阻止了事件的进一步传播。 12345678910111213141516171819202122&lt;div id="superDiv" name="superDiv" value="hello"&gt; &lt;div id="subDiv"&gt;&lt;/div&gt;&lt;/div&gt;superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式"); event.stopPropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式");&#125;,false);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 冒泡模式");&#125;,false);// superDiv 捕获模式 点击 subDiv，输出结果只有捕获模式下的 superDiv，后续的事件捕获和冒泡都被阻止了。 发现一个问题就是，元素不管是在捕获还是冒泡模式下，都可以使用 stopPropagation()，然后打印出捕获模式下的事件对象的 bubbles 属性发现是 true。个人认为，不管是在捕获还是冒泡模式下，bubbles 的值除非设置为 false，默认值都是 true。 与 stopPropagation() 不同的是，stopPropagation() 可以阻止事件进一步传播，但是不能阻止该元素上绑定的其他函数的执行。比如我们在元素绑定了函数 1 和函数 2，我们在函数 1 上使用了stopPropagation()，那函数 2 还是会执行，但用 stopImmediatePropagation() 就不会了，它会阻止元素上绑定的所有事件处理函数执行。 123456789101112131415superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式-函数1"); event.stopPropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式-函数2");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);// superDiv 捕获模式-函数1// superDiv 捕获模式-函数2 使用 event.stopPropagation() 方法，会阻止事件进一步冒泡或捕获，不会阻止该元素上绑定的其他函数的执行。 1234567891011121314superDiv.addEventListener("click",function(event) &#123; console.log("superDiv 捕获模式-函数1"); event.stopImmediatePropagation();&#125;,true);superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式-函数2");&#125;,true);subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式");&#125;,true);// superDiv 捕获模式-函数1 使用 event.stopImmediatePropagation() 不但会阻止事件的进一步冒泡或捕获，也会阻止该元素上绑定的其他函数执行。 在 IE 事件流中，cancelBubble属性 的作用与 stopPropagation() 方法相同。 1event.cancelBubble = true; // 阻止进一步冒泡 取消事件的默认行为在使用 JavaScript 编程时会遇到一个问题，就是当你给html添加事件时，由于浏览器默认的事件触发机制，可能会触发你不想触发的行为，例如，当点击提交按钮时会对表单进行提交，点击链接时会跳转到指定页面。 在 DOM 事件流中，调用事件对象的 preventDefault() 方法，在 IE 事件流中，设置事件对象的 returnValue 属性值为 false。 123DOM：preventDefault()IE：returnValue = false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件模型系列（二）事件流与事件代理]]></title>
      <url>%2F2017%2F04%2F03%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[事件流定义为什么会有事件流这个概念呢？ 我们想象一组同心圆，当你点击圆心的时候，实际上，你点击了所有圆。就比如你点击了页面中的一个按钮，同时你也点击了这个按钮的父容器，因为这个按钮是属于这个容器的，然后一层一层向上，可以说你也点击了这个页面。因此我们需要确定这些元素接受事件的先后顺序。 因此事件流的定义其实就是，从页面中接受事件的顺序。 在处理事件流的时候，IE 和 Netscape 采取了两种截然不同的处理方式。 事件冒泡（event bubbling）：IE事件流事件冒泡是指从最具体的元素开始，逐级向上传播直到 document。123456789101112131415161718192021222324&lt;div id="superDiv"&gt;superDiv &lt;div id="subDiv"&gt;subDiv&lt;/div&gt;&lt;/div&gt;document.addEventListener("click",function() &#123; console.log("document 冒泡模式");&#125;,false);superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式");&#125;,false);subDiv.addEventListener("click",function(event) &#123; console.log("subDiv 冒泡模式");&#125;,false);// 点击 subDiv// subDiv 冒泡模式// superDiv 冒泡模式// document 冒泡模式// 点击 superDiv// superDiv 冒泡模式// document 冒泡模式 在冒泡模式下，点击 subDiv，subDiv（作为最具体的元素）接收到事件，执行事件处理程序，打印 subDiv 冒泡模式，执行完毕后，冒泡到上一级元素，执行 superDiv 的事件处理程序，打印 superDiv 冒泡模式，直到 document。 在冒泡模式下，点击 superDiv，则不会执行 subDiv 的事件绑定程序，向上冒泡到 document。 事件捕获（event capturing）与事件冒泡相反，事件最开始由不太具体的节点接受，最具体的节点最后接受。 DOM 事件流为了天下一统的局面，DOM 事件流中既包含了事件冒泡也包含了事件捕获。 DOM 事件流分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获阶段： 事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。 处于目标阶段： 事件到达目标元素, 触发目标元素的监听函数。 事件冒泡阶段： 事件从目标元素向上传播到 document，冒泡前进，遇到事件监听函数则执行。 12345678910111213141516&lt;div id="superDiv"&gt; &lt;div id="subDiv"&gt;&lt;/div&gt;&lt;/div&gt;superDiv.addEventListener("click",function() &#123; console.log("superDiv 捕获模式"); &#125;,true); superDiv.addEventListener("click",function() &#123; console.log("superDiv 冒泡模式"); &#125;,false); subDiv.addEventListener("click",function() &#123; console.log("subDiv 捕获模式"); &#125;,true); subDiv.addEventListener("click",function() &#123; console.log("subDiv 冒泡模式"); &#125;,false); 执行结果： 对于 DOM 事件流，我们要明确一点，在给一个元素或文档绑定事件时，通常使用捕获或者冒泡的一种。在 DOM 事件流中，我们可以设置这个事件处理程序是在捕获阶段发生还是在冒泡阶段发生，这个元素上的事件只会触发一次。 事件代理事件代理，又叫事件委托，就是将应该加在某个元素上的事件处理程序，（委托）加到其他的元素上，完成这个事件。 最常见的就是将原本需要绑定在子类元素上的事件处理程序，（委托）绑定到父类元素上。通过父类元素上的事件处理程序管理所有子类事件。 比如说，有一个 ul 列表，里面有很多的 li 列表项，点击不同的 li，执行不同的事件处理函数，我们就需要给每一个 li 列表项绑定事件处理程序，这样会造成代码整体性能下降，因为事件处理程序是一个函数，函数是对象，对象都是保存在堆中的（内存中），内存中的对象越多，性能越差。 根据事件流模型，我们点击了 li 列表项，同时也点击了 ul 列表，再根据事件冒泡原理，事件从 li 向上传播到 ul，我们将事件处理程序绑定的 ul 上，再结合事件对象对 li 进行相同或不同的处理。 12345678910111213141516171819202122232425&lt;ul id="myLinks"&gt; &lt;li id="goSomewhere"&gt;Go Somewhere&lt;/li&gt; &lt;li id="doSomething"&gt;Do Soemthing&lt;/li&gt; &lt;li id="sayHi&gt;Say Hi&lt;/li&gt;&lt;/ul&gt;var list = document.getElementById("myLinks");addHandler(list,"click",function(event) &#123; // 结合事件对象实现事件委托 event = getEvent(event); var target = getTarget(event); switch() &#123; case "goSomewhere": location.href = "http://www.wrox.com"; break; case "doSomething": document.title = "I change the document's title"; break; case "sayHi": alert("hi"); break; &#125;&#125;); 优点： 提高性能，可以大量节省内存占用，减少事件注册 新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适 缺点： 滥用可能出现事件误判，即本不该应用触发事件的元素被绑定上了事件。 总结 事件流的定义 IE、网景、DOM 事件流 事件代理 定义 原理 优缺点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件模型系列（一）事件与事件处理程序]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[基本定义事件： 事件就是浏览器或者用户执行的某种动作，比如文档加载完毕（load）、鼠标点击（click）等等。 事件处理程序： 事件处理程序是响应事件的函数。事件处理程序可以看做是动作的结果，比如文档加载完毕或者点击鼠标之后会发生什么。 为一个事件添加事件处理程序有四种方式。分别为：HTML、DOM0级、DOM2级、IE。 事件处理程序HTML 事件处理程序最开始学习 JavaScript 的时候，用到的就是 HTML 事件处理程序，就是直接在 HTML 代码中添加事件处理程序。 比如直接在 HTML 标签内添加： 1&lt;button id="btn" onclick="console.log('clicked');"&gt;Click Me&lt;/button&gt; 或添加到 script 标签中（外部 js 文件）： 123456&lt;button id="btn" onclick="show();"&gt;&lt;/button&gt;&lt;script&gt; function show() &#123; console.log("clicked"); &#125;&lt;/script&gt; 优点： 123&lt;button id="btn" onclick="console.log(event.type);"&gt;Click Me&lt;/button&gt; // click &lt;button id="btn" onclick="console.log(this.id);"&gt;Click Me&lt;/button&gt; // btn 可以通过 event 函数直接访问事件对象，比如 event.type 在函数内部，this 指向事件的目标元素，在上面第二行代码中，this 指向的就是这个 button 元素 事件处理程序中的代码在执行时，有权访问到全局作用域中的任何代码，这就是为什么我们可以把函数定义在 script 中，同样也可以调用 缺点： 时差问题： 用户可能在 HTML 元素一出现就触发事件，而此时该事件的脚本可能还没有加载完成 HTML 与 JavaScript 代码紧密耦合 DOM0 级事件处理程序将一个函数赋值给一个事件处理程序属性。比如： 123456&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.onclick = function() &#123; console.log("clicked");&#125; 在 DOM0 级事件处理程序中，this 指向的是这个对象。 优点： HTML 与 JavaScript 代码联系不紧密。 缺点： 不能给一个元素同时添加多个相同的事件处理程序，后添加的事件事件处理程序会覆盖之前的。 1234567btn.onclick = function() &#123; console.log("clicked1");&#125;btn.onclick = function() &#123; console.log("clicked2");&#125;// clicked2 DOM2级事件处理程序DOM2 级事件处理程序用到的是 addEventListenter 方法。 1element.addEventListener(type,handler,ture/false); 注意在 DOM2 级事件处理程序中，type 是不带 on 的，handler 是事件处理函数，true 表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用。 1234567&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function() &#123; console.log("clicked");&#125;,false); // 冒泡阶段调用 移除：通过 addEventListenter() 添加的事件处理程序，只能通过 removeEventListenter() 移除。 12345var handler = function() &#123; console.log("clicked");&#125;btn.addEventListener("click",handler,false); // 添加btn.removeEventListener("click",handler,false); // 移除 优点： 可以一个事件添加多个事件处理程序 浏览器支持性好 HTML 与 JavaScript 代码联系不紧密 123456789101112&lt;button id="btn""&gt;Click Me&lt;/button&gt;var btn = document.getElementById("btn");btn.addEventListener("click",function() &#123; console.log("clicked1");&#125;,false);btn.addEventListener("click",function() &#123; console.log("clicked2");&#125;,false);// clicked1 clicked2 缺点： 通过 addEventListenter() 添加的匿名函数无法移除 IE8 及以下版本不支持该方法 IE事件处理程序与 DOM2 级事件处理程序类似，IE 提供了 attachEvent() 和 detachEvent() 方法。不同之处在于，IE 事件处理程序只在冒泡阶段触发。 1element.attachEvent(type,handler); 注意 IE 事件处理程序，type 要带 on，handler 是事件处理函数。 12345var handler = function() &#123; console.log("clicked");&#125;btn.attachEvent("onclick",handler); // 添加btn.detachEvent("onclick",handler); // 移除 优点： 可以一个事件添加多个事件处理程序 HTML 与 JavaScript 代码联系不紧密 缺点： 只有 IE 和 Opera 支持。 跨浏览器事件处理程序为了兼容所有浏览器，我们可以封装一个事件处理程序： 12345678910111213141516171819202122232425// 绑定事件var addHandler = function(element,type,handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type,handler,false); &#125; else if (element.attachEvent)&#123; element.attachEvent("on"+type,handler); &#125; else &#123; element["on"+type]=handler; &#125;&#125;// 移除事件var reomoveHandler = function(element,type,handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type,handler,false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on"+type,handler); &#125; else &#123; element["on"+type]=null; &#125;&#125; 总结 事件的定义 事件处理程序的定义 事件处理程序的四种模型 代码 原理 优缺点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网易2017春招笔试编程题]]></title>
      <url>%2F2017%2F04%2F01%2F%E7%BD%91%E6%98%932017%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
      <content type="text"><![CDATA[消除重复元素题目描述小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难，希望你来帮助他。 输入包括两行： 第一行为序列长度n(1 ≤ n ≤ 50)。 第二行为n个数sequencei，以空格分隔。 输入例子： 9 100 100 100 99 99 99 100 100 100 输出消除重复元素之后的序列，以空格分隔，行末无空格。 输出例子： 99 100 思路输入是一个可能包含有多个重复元素的数组（inputArr）： 用一个数组（noRepeatArr）存储输入数组中独立的元素，就是一个输入数组去重的过程； 将所有元素最后出现的索引值存在一个数组中（index），用到 arr.lastIndexOf(element) 方法； 将 index 数组从小到大排序，按排好序的索引值从输入数组中取出相应元素即可。 代码123456789101112131415161718192021function findLastPosition(inputArr) &#123; var noRepeatArr = []; var inputLen = inputArr.length; var index = []; var outputArr = []; for (var i = 0; i &lt; inputLen; i++) &#123; if (noRepeatArr.indexOf(inputArr[i])==-1) &#123; // noRepeat中没有该元素 noRepeatArr.push(inputArr[i]); &#125; &#125; for (var j = 0; j &lt; noRepeatArr.length; j++) &#123; index.push(inputArr.lastIndexOf(noRepeatArr[j])); &#125; index.sort(function(a,b) &#123; return a-b; &#125;); for (var k = 0; k &lt; index.length; k++) &#123; outputArr.push(inputArr[index[k]]); &#125; return outputArr;&#125; 奇怪的表达式求值题目描述常规的表达式求值，我们都会根据计算的优先级来计算。比如 / 的优先级就高于 + -。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有 /，只有+，- 和 。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 输入为一行字符串，即一个表达式。其中运算符只有 -，+，*。参与计算的数字只有 0-9。 输出一个数，即表达式的值。 输入例子: 3+5*7 输出例子: 56 思路考虑到数字只有0-9，先取出字符串的前三个字符（str.substring），计算出这三个字符的值（eval函数），然后再用一个循环每次取后两个字符加入计算。 代码1234567function strangeExpression(inputExpStr) &#123; var result = eval(inputExpStr.substring(0,3)); for (var i = 3; i &lt; inputExpStr.length; i+=2) &#123; result = eval(result + inputExpStr.substring(i,i+1)); &#125; return result;&#125; 集合题目描述小易最近在数学课上学习到了集合的概念，集合有三个特征：1. 确定性；2. 互异性；3. 无序性。 小易的老师给了小易这样一个集合：S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z } 需要根据给定的w，x，y，z，求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题，需要你来帮助他。 输入包括一行：一共4个整数分别是w(1 ≤ w ≤ x)，x(1 ≤ x ≤ 100)，y(1 ≤ y ≤ z)，z(1 ≤ z ≤ 100)，以空格分隔。 输出描述：输出集合中元素的个数。 输入例子: 1 10 1 1 输出例子: 10 代码12345678910111213141516function eleNumInSet(w,x,y,z) &#123; var sAll = []; var s = []; for (var i = w; i &lt;= x; i++) &#123; // p 集合 for (var j = y; j &lt;= z; j++) &#123; // q 集合 sAll.push(i/j); &#125; &#125; // 去重 for (var k = 0; k &lt; sAll.length; k++) &#123; if (s.indexOf(sAll[k])==-1) &#123; s.push(sAll[k]); &#125; &#125; return s.length;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FCC Basic Algorithm Scripting 基础算法集]]></title>
      <url>%2F2017%2F03%2F31%2FFCC%20Basic%20Algorithm%20Scripting%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%9B%86%2F</url>
      <content type="text"><![CDATA[前言本文为 FreeCodeCamp 中前端的十六道基础算法题。 Reverse a String 翻转字符串★ 具体步骤 字符串 –&gt; 数组：str.split(“连接符”) 翻转数组：arr.reverse()，本方法直接改变原数组 数组 –&gt; 字符串：arr.join(“连接符”) ★ 代码123456789function reverseString(str) &#123; var arr = new Array(); arr = str.split(""); arr.reverse(); str = arr.join(""); return str;&#125;reverseString("hello"); // olleh Factorialize a Number 计算一个整数的阶乘★ 具体步骤 分情况：if 判断 n=0，n&gt;0 循环计算：n=0 时，n!=1，n&gt;0 时，循环累乘 n!=1×2×···×n ★ 代码1234567891011121314function factorialize(num) &#123; var sum = 1; if (num == 0) &#123; sum = 1; &#125; else &#123; for (var i = 1; i &lt;= num; i++) &#123; sum = sum * i; &#125; &#125; return sum;&#125;factorialize(5); // 120 Check for Palindromes 判断回文★ 要求 回文（palindrome）：一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，例如 eye。 如果给定的字符串是回文，返回 true，反之，返回 false。 ★ 思路去掉字符串多余的标点符号和空格，然后把字符串转化成小写，翻转之后检查是否与原字符串相等。 ★ 具体步骤 用正则表达式找到字符串多余的标点符号和空格（找出字母和数字即可） 去除非字母数字符号：str.replace(被替换部分,替换部分) 将字符串转为小写：str.toLowerCase() 将字符串翻转：见第一题 判断翻转后的字符串与原来的是否相同 正则表达式：用来匹配字符串中字符组合的模式。其中 W 表示字母、数字、下划线，因此 [\W_] 就可以表示非字母数字了，也可以用 [^A-Za-z0-9] 表示 ★ 代码12345678function palindrome(str) &#123; var re = /[\W_]/g; var newStr = str.replace(re,"").toLowerCase(); // 纯字母数字的小写形式 var reverseStr = newStr.split("").reverse().join(""); return reverseStr == newStr;&#125;palindrome("eye"); // true Find the Longest Word in a String 找到提供的句子中最长的单词，并计算它的长度★ 思路将字符串转为数组，记录下每个数组元素的长度，将长度排序。 ★ 具体步骤 将字符串转为数组：split() 循环：将每个数组元素的长度保存在新数组中 排序：将长度数组排序 sort()，得到最大长度值 ★ 代码123456789101112131415161718function findLongestWord(str) &#123; var arr = new Array(); var arrLen = new Array(); arr = str.split(" "); for (var i = 0; i &lt; arr.length; i++)&#123; arrLen[i] = arr[i].length; &#125; arrLen.sort(function(a,b) &#123; return b-a; &#125;); return arrLen[0];&#125;findLongestWord("The quick brown fox jumped over the lazy dog"); // 6 Title Case a Sentence 字符串的单词首字母大写其余小写★ 思路先将所有字母统一为小写，再将字符串转化为数组，将每一个数组元素的第一个字符变为大写。 ★ 具体步骤 转小写：将字符串中所有字母转为小写 str.toLowerCase() 字符串 –&gt; 数组：str.split() 遍历数组，将每个数组元素第一个字母替换为大写 遍历 arr.map() 替换 arr.replace() 单字符 arr.charAt(index) 大写 toUpperCase() 数组 –&gt; 字符串：arr.join() ★ 代码123456789101112131415161718function titleCase(str) &#123; str = str.toLowerCase(); var arr = new Array(); arr = str.split(" "); var newArr = new Array(); newArr = arr.map(toUpper); function toUpper(element) &#123; return element.replace(element.charAt(0),element.charAt(0).toUpperCase()); &#125; str = newArr.join(" "); return str;&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot Return Largest Numbers in Arrays 将小数组们的最大值串联成新数组★ 要求大数组中包含了若干个小数组，分别找到每个小数组中的最大值（数值的最大值），然后把它们串联起来，形成一个新数组。 ★ 具体步骤 先把大数组分为若干小数组 循环小数组中每一个元素 找到每个小数组中的最大值 用新数组存储最大值 ★ 代码1234567891011121314151617function largestOfFour(arr) &#123; var newArr = new Array(); for (var i = 0; i &lt; arr.length; i++) &#123; var max = arr[i][0]; // max 要定义在内层循环外 for (var j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] &gt;= max) &#123; max = arr[i][j]; &#125; &#125; newArr[i] = max; &#125; return newArr;&#125;largestOfFour([[4,5,1,3],[13,27,18,26],[32,35,37,39],[1000,10001,857,1]]); // [5,27,39,10001] Confirm the Ending 检查一个字符串是否以指定的字符串结尾★ 思路首先要知道指定字符串 target 的个数，找到待检查字符串中最后几位，判断两者是否相等。 ★ 具体步骤str.substr(beginindex,endindex) 方法：返回字符串从指定位置开始，到指定长度的字符串。 ★ 代码12345function confirmEnding(str,target) &#123; return target == str.substr(str.length-target.length,target.length);&#125;confirmEnding("Bastian","n"); // true Repeat a string repeat a string 重要的事情说3遍★ 要求重复一个指定的字符串 num 次，如果 num 是一个负数则返回一个空字符串。 ★ 具体步骤 保留原始字符串：var newStr = str 循环 ★ 代码1234567891011121314function repeat(str,num) &#123; var newStr = str; if (num &gt; 0) &#123; for (var i = 0; i &lt; num; i++) &#123; newStr = newStr.concat(str); &#125; &#125; else &#123; newStr = ""; &#125; return newStr;&#125;repeat("abc",3); // abcabcabcabc Truncate a string 用瑞兹来截断对面的退路★ 要求如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度 ★ 思路最开始要判断 num 是否大于字符串长度。 当 num 小于字符串长度时，分 num 小于等于 3 和大于 3 的情况； 当 num&lt;=3 时，直接在字符串后面加三个点； 当 num&gt; 3时，字符串 + 三个点的长度 = num。 ★ 具体步骤 num&lt;=3：str.slice()、str.concat(“…”) num&gt;3：str.slice()、str.concat(“…”) ★ 代码12345678910111213141516171819function truncate(str,num) &#123; var newStr; if (num &lt; str.length) &#123; if (num &lt;= 3) &#123; newStr = str.slice(0,num); newStr = newStr.concat("..."); &#125; else &#123; newStr = str.slice(0,num-3); newStr = newStr.concat("..."); &#125; &#125; else &#123; newStr = str; &#125; return newStr;&#125;truncate("A-tisket a-tasket A green and yellow basket","A-tisket a-tasket A green and yellow basket".length+2); // A-tisket a-tasket A green and yellow basket Chunky Monkey 猴子吃香蕉可是掰成好几段来吃哦★ 要求把一个数组 arr 按照指定的数组大小 size 分割成若干个数组块。 ★ 思路将分割出的数组块当作一个个数组元素存在一个新的数组中，要确定分割的个数，才好循环。 ★ 具体步骤设定切割起始位置 begin 与 end，并按照 size 大小累加，将切下的数组块循环 push 进新数组中。 arr.slice(beginindex,endindex)，切割时包括 beginindex，不包括 endindex。 注意 arr.push() 返回的是长度值。 ★ 代码123456789101112131415function chunk(arr,size) &#123; var newArr = new Array(); var begin = 0; var end = size; for (var i = 0; i &lt; arr.length/size; i++) &#123; newArr.push(arr.slice(begin,end)); begin = begin + size; end = end + size; &#125; return newArr;&#125;chunk(["a","b","c","d","e"],2); // [["a","b"],["c","d"]["e"]] Slasher Flick 打不死的小强★ 要求返回一个数组被截断 n 个元素后还剩余的元素，截断从索引 0 开始（删除数组前 n 个元素） ★ 具体步骤1array.splice(start, deleteCount[, item1[, item2[, ...]]]) start 为开始索引值，deleteCount 为整数，表示要移出的元素个数，item1 表示要添加的元素，若无，则函数只删除元素。函数返回被删除元素数组。 ★ 代码12345function slasher(arr,howMany) &#123; return arr.splice(howMany,arr.length-howMany);&#125;slasher([1,2,3],2); // [3] Mutations 蛤蟆可以吃队友，也可以吃对手★ 要求如果数组第一个字符串元素包含了第二个字符串元素的所有字符，忽略顺序和大小写，函数返回 true。 例如：[&quot;hello&quot;, &quot;hey&quot;] 应该返回 false，因为字符串 &quot;hello&quot; 并不包含字符 &quot;y&quot; 再例如：[&quot;Alien&quot;, &quot;line&quot;] 应该返回 true，因为 &quot;line&quot; 中所有字符都可以在 &quot;Alien&quot; 找到 ★ 思路首先要将两个字符串统一为小写，再看第二个字符串中的所有元素是不是都能在第一个字符串中找到。 ★ 具体步骤 数组-&gt;字符串：个数较少，直接用下标赋值 字符串转小写：str.toLowerCase() 第二个字符串 –&gt; 数组：str.split() 检查第二个字符串中的每个字符是否都能在第一个字符串中找到 ★ 代码12345678910111213141516171819function mutation(arr) &#123; var str1 = arr[0].toLowerCase(); var str2 = arr[1].toLowerCase(); var arr2 = new Array(); arr2 = str2.split(""); for (var i = 0; i &lt; arr2.length; i++) &#123; if (str1.indexOf(arr2[i]) == -1) &#123; return false; &#125; else &#123; continue; &#125; &#125; return true;&#125;mutation(["hello","hey"]); // false Falsy Bouncer 真假美猴王★ 要求删除数组中的所有假值。 在JavaScript中，假值有 false、null、0、””、undefined 和 NaN ★ 思路遍历数组，判断是否为假值，是则删除，否则留下。 ★ 具体步骤 遍历数组：arr.filter() 判断是否为假值：Boolean(element)。element 为假值返回 false，真值返回 true ★ 代码123456789function bouncer(arr) &#123; var newArr = arr.fliter(delFalsy); function delFalsy(element) &#123; return Boolean(element); &#125; return newArr;&#125;bouncer([7,"ate","",false,9]); // [7,"ate",9] Seek and Destroy 金克斯的迫击炮★ 要求实现一个摧毁 destroyer 函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 例如：destroyer([1, 2, 3, 1, 2, 3], 2, 3) 应该返回 [1, 1] ★ 思路遍历数组，将与待摧毁值相同的数组元素删除。 ★ 具体步骤 将待摧毁值存入一个数组中：arguments[index] 遍历数组：arr.filter() 判断是否要摧毁：循环+判断 ★ 注意 filter 是根据其函数返回值判断是否保留该元素，true 为保留，false 为删除。注意循环的结束与跳过情况 arguments[index] 不要放在内部函数中，这样将取不到外部函数的参数 循环中最好不要调用函数 ★ 代码12345678910111213141516171819202122232425262728293031function destroyer() &#123; var arr = arguments[0]; var a = new Array(); var num = arguments.length; var j = 0; for (var i = 1; i &lt; num; i++) &#123; a[j] = arguments[i]; // 待摧毁数组 j++; &#125; var newArr = arr.filter(destroy); function destroy(element) &#123; for (var k = 0; k &lt; num-1; k++) &#123; var res; if (element == a[k]) &#123; res = false; break; &#125; else &#123; res = true; continue; &#125; return res; &#125; return newArr; &#125; &#125;destroyer([1,2,3,1,2,3],2,3); // [1,1] Where do I belong 我身在何处★ 要求先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 例如：where([1,2,3,4], 1.5) 返回 1 因为 1.5 插入到数组 [1,2,3,4] 后变成 [1,1.5,2,3,4]，而 1.5 对应的索引值就是 1 ★ 具体步骤 指定元素放入数组：arr.push() 数组排序：从小到大 arr.sort() 找到指定元素的索引：arr.indexOf() ★ 代码123456789function where(arr,num) &#123; arr.push(num); arr.sort(function(a,b) &#123; return a-b; // 从小到大 &#125;); return arr.indexOf(num);&#125;where([40,60],50); // 1 Caesars Cipher 让上帝的归上帝，凯撒的归凯撒（凯撒编码）★ 要求写一个 ROT13 函数，实现输入加密字符串，输出解密字符串。注意：所有的字母都是大写，不要转化任何非字母形式的字符（例如：空格，标点符号），遇到这些特殊字符，跳过它们。 ROT13：http://www.baike.com/wiki/ROT13&amp;prd=so_1_doc ★ 思路将 A-M 的 Unicode 值 +13，将 N-Z 的 Unicode 值-13。 ★ 具体步骤 得到字符串中每个字母的 Unicode(UTF16) 值：str.charCodeAt(index) 返回 0~65535 之间的整数 将 A-M 的 Unicode 值 +13，将 N-Z 的 Unicode 值 -13，其余字符不变 Unicode值 –&gt; 字母：String.fromCharCode(Unicode值) ★ 代码12345678910111213141516171819202122function rot13(str) &#123; var arr = new Array(); for (var i = 0; i &lt; str.length; i++) &#123; var utfNum = str.charCodeAt(i); if (utfNum &gt;= 65 &amp;&amp; utfNum &lt;= 90) &#123; if (utfNum &lt;= 77) &#123; utfNum += 13; &#125; else &#123; utfNum -= 13; &#125; &#125; arr[i] = String.fromCharCode(utfNum); &#125; str = arr.join(""); return str;&#125;rot13("SERR CVMMN!"); // "FREE PIZZA!"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo在Github上搭建个人博客]]></title>
      <url>%2F2017%2F03%2F30%2F%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[准备工作Node.js官网下载地址：https://nodejs.org/en/ 傻瓜式安装过程【略】 Github申请账号Github 官网：https://github.com/ 注册账号【略】 新建博客仓库New repository –&gt; 仓库名的格式必须为：用户名.github.io –&gt; 进入仓库后，点击 settings –&gt; 在Options 菜单栏中找到 GitHub Pages 选项 部分教程中，这个选项中有 Launch automatic page generator 按钮，此时直接点击就可以了。 但在我的 Github Page 页面中并没有这个选项，只有 Choose a theme 按钮，点进去会让你选择主题，同样也可以生成 Github Page，但此时是基于 Jekyll 框架的。 Git下载安装官网下载地址：https://git-scm.com/download/ 配置环境变量右击计算机 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 在系统变量中找到 path 变量，加入 Git 的两个路径： D:\Program Files\Git\bin D:\Program Files\Git\libexec\git-core 注意不同环境变量中不同路径要加分号（英文半角），libexec 文件夹不一定就在 Git 目录下，Git2.0 以上版本的在 Git 目录下的 mingw32 文件夹中。 关联 Github 账号随处右击进入 GitBash，输入命令行： 12git config --global user.name "用户名"git config --global user.email "邮箱地址" SSH Keys接着上一步，输入命令行： 1ssh-keygen -t rsa -C "邮箱地址" 连续回车，生成两个文件 id_rsa 和 id_rsa.pub，打开 id_rsa.pub 复制所有内容。 登录网页版 Github，点击头像 –&gt; Settings –&gt; SSH and GPG keys –&gt; 点击 New SSH key 按钮 –&gt; Title随意，将刚刚复制的内容粘贴到 Key 中 –&gt; Add SSH Key 结束。 安装 Hexo进入 Node.js 的安装路径，新建一个文件夹（我这里取名为 blog），进入 blog 文件夹，打开命令行窗口（按住 Shift 键，鼠标右键，选择在此处打开命令窗口），依次输入命令： 安装 Hexo： 1npm install -g hexo 初始化： 1hexo init 生成静态界面： 1hexo g 启动本地服务，进行文章预览调试 1hexo s 此时在浏览器中输入 http://localhost:4000 可以看到这样的页面： 打开 D:\Program Files\nodejs\blog\source_posts 就可以看到一个 hello-world.md 的文件，这就是网站上显示的文章，之后写的博客都是以 md 格式存在这个文件夹中。 配置 Github打开 nodejs\blog 文件夹下的 _config.yml 文件，拉到最下面，修改为： 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 继续执行配置命令： 1hexo d 完成上述步骤之后，在浏览器中输入 http://用户名.github.io 就可以了。 部署步骤每次部署的步骤，可以按以下三步进行： 12345hexo cleanhexo generate // hexo ghexo deploy // hexo d 更换 Hexo 主题我使用的主题是：https://github.com/iissnan/hexo-theme-next 打开主题所在文件夹 nodejs\blog\themes，打开 GitBsh 或者命令行，输入下载主题命令: 1git clone https://github.com/iissnan/hexo-theme-next.git 再执行命令（没有执行如下命令会报错） 12npm install hexo-renderer-jade --savenpm install hexo-renderer-sass --save 下载完成后，会看到 themes 下多了一个文件夹，修改文件名为 next，修改 nodejs\blog 文件夹下的 _config.yml 文件，将 theme 值修改为：next，注意 theme 冒号后的空格要保留。 再次执行命令: 12hexo ghexo d 就可以看到主题更换成功了。 报错信息处理报错 spawn git ENOENT在配置 Github 中最后输入 hexo d 后报错 spawn git ENOENT 解决方法： 添加 Git 环境变量，还不行的话将 Git 版本退回到 2.0 以下。 报错 not a git repository解决了上一个报错之后，出现 not a git repository 报错信息 解决方法： 删除 nodejs\blog 文件夹下的 .deploy_git 文件夹并且执行 hexo clean 后，重新 hexo g 和 hexo d。 报错 Cannot find module ‘hexo-util’更换完主题之后，再次执行 hexo clean 时报错，报错信息： 解决方法： 重新安装 hexo-util 模块即可，在 \nodejs\blog 下输入命令：1npm install -- save-dev hexo-util 关于 Hexo 的更多设置添加评论系统我使用的评论系统是：disqus。 注册账号disqus 官网地址：https://disqus.com 添加网址在设置过程中会需要填你的网站地址，填入 https://用户名.github.io 即可 找到 short_name由于在最初设置的时候没注意 Choose your unique Disqus URL 这一栏填的是什么，其实这一栏中的内容就是你的 short_name，在你的用户界面点击 Settings 菜单栏。 修改文件打开根目录（nodejs\blog）下的 _config.yml 文件，在最后面添加： 1disqus_shortname: your_disqus_short_name 再打开 nodejs\blog\themes\next，找到 _config.yml 文件，找到如下代码修改完即可： 首页文章只显示预览修改文件目录：nodejs\blog\themes\next，找到 _config.yml 文件，找到如下代码： 将 false 修改为 true 即可。]]></content>
    </entry>

    
  
  
</search>
